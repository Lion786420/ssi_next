"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-utils";
exports.ids = ["vendor-chunks/web3-utils"];
exports.modules = {

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/chunk_response_parser.js":
/*!*************************************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/chunk_response_parser.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChunkResponseParser = void 0;\nconst web3_errors_1 = __webpack_require__(/*! web3-errors */ \"(api)/./src/pages/api/node_modules/web3-errors/lib/commonjs/index.js\");\nclass ChunkResponseParser {\n    constructor(eventEmitter, autoReconnect) {\n        this.eventEmitter = eventEmitter;\n        this.autoReconnect = autoReconnect;\n        this.chunkTimout = 1000 * 15;\n    }\n    clearQueues() {\n        if (typeof this._clearQueues === 'function') {\n            this._clearQueues();\n        }\n    }\n    onError(clearQueues) {\n        this._clearQueues = clearQueues;\n    }\n    parseResponse(data) {\n        const returnValues = [];\n        // DE-CHUNKER\n        const dechunkedData = data\n            .replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n            .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n            .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n            .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n            .split('|--|');\n        dechunkedData.forEach(_chunkData => {\n            // prepend the last chunk\n            let chunkData = _chunkData;\n            if (this.lastChunk) {\n                chunkData = this.lastChunk + chunkData;\n            }\n            let result;\n            try {\n                result = JSON.parse(chunkData);\n            }\n            catch (e) {\n                this.lastChunk = chunkData;\n                // start timeout to cancel all requests\n                if (this.lastChunkTimeout) {\n                    clearTimeout(this.lastChunkTimeout);\n                }\n                this.lastChunkTimeout = setTimeout(() => {\n                    if (this.autoReconnect)\n                        return;\n                    this.clearQueues();\n                    this.eventEmitter.emit('error', new web3_errors_1.InvalidResponseError({\n                        id: 1,\n                        jsonrpc: '2.0',\n                        error: { code: 2, message: 'Chunk timeout' },\n                    }));\n                }, this.chunkTimout);\n                return;\n            }\n            // cancel timeout and set chunk to null\n            clearTimeout(this.lastChunkTimeout);\n            this.lastChunk = undefined;\n            if (result)\n                returnValues.push(result);\n        });\n        return returnValues;\n    }\n}\nexports.ChunkResponseParser = ChunkResponseParser;\n//# sourceMappingURL=chunk_response_parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9jaHVua19yZXNwb25zZV9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCLHNCQUFzQixtQkFBTyxDQUFDLHlGQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTLE1BQU0sS0FBSztBQUM1Qyx3QkFBd0IsYUFBYSxNQUFNLE9BQU8sT0FBTztBQUN6RCx3QkFBd0IsV0FBVyxNQUFNLE1BQU0sT0FBTztBQUN0RCx3QkFBd0IsV0FBVyxNQUFNLE1BQU0sT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUNBQW1DO0FBQ3BFLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXNzdWVyX2hvbGRlcl92ZXJpZmllci8uL3NyYy9wYWdlcy9hcGkvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL2NvbW1vbmpzL2NodW5rX3Jlc3BvbnNlX3BhcnNlci5qcz84MmIyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaHVua1Jlc3BvbnNlUGFyc2VyID0gdm9pZCAwO1xuY29uc3Qgd2ViM19lcnJvcnNfMSA9IHJlcXVpcmUoXCJ3ZWIzLWVycm9yc1wiKTtcbmNsYXNzIENodW5rUmVzcG9uc2VQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKGV2ZW50RW1pdHRlciwgYXV0b1JlY29ubmVjdCkge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5hdXRvUmVjb25uZWN0ID0gYXV0b1JlY29ubmVjdDtcbiAgICAgICAgdGhpcy5jaHVua1RpbW91dCA9IDEwMDAgKiAxNTtcbiAgICB9XG4gICAgY2xlYXJRdWV1ZXMoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY2xlYXJRdWV1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyUXVldWVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25FcnJvcihjbGVhclF1ZXVlcykge1xuICAgICAgICB0aGlzLl9jbGVhclF1ZXVlcyA9IGNsZWFyUXVldWVzO1xuICAgIH1cbiAgICBwYXJzZVJlc3BvbnNlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgcmV0dXJuVmFsdWVzID0gW107XG4gICAgICAgIC8vIERFLUNIVU5LRVJcbiAgICAgICAgY29uc3QgZGVjaHVua2VkRGF0YSA9IGRhdGFcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXH1bXFxuXFxyXT9cXHsvZywgJ318LS18eycpIC8vIH17XG4gICAgICAgICAgICAucmVwbGFjZSgvXFx9XFxdW1xcblxccl0/XFxbXFx7L2csICd9XXwtLXxbeycpIC8vIH1dW3tcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXH1bXFxuXFxyXT9cXFtcXHsvZywgJ318LS18W3snKSAvLyB9W3tcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXH1cXF1bXFxuXFxyXT9cXHsvZywgJ31dfC0tfHsnKSAvLyB9XXtcbiAgICAgICAgICAgIC5zcGxpdCgnfC0tfCcpO1xuICAgICAgICBkZWNodW5rZWREYXRhLmZvckVhY2goX2NodW5rRGF0YSA9PiB7XG4gICAgICAgICAgICAvLyBwcmVwZW5kIHRoZSBsYXN0IGNodW5rXG4gICAgICAgICAgICBsZXQgY2h1bmtEYXRhID0gX2NodW5rRGF0YTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RDaHVuaykge1xuICAgICAgICAgICAgICAgIGNodW5rRGF0YSA9IHRoaXMubGFzdENodW5rICsgY2h1bmtEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShjaHVua0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDaHVuayA9IGNodW5rRGF0YTtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCB0aW1lb3V0IHRvIGNhbmNlbCBhbGwgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0Q2h1bmtUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmxhc3RDaHVua1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDaHVua1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JlY29ubmVjdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclF1ZXVlcygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdlcnJvcicsIG5ldyB3ZWIzX2Vycm9yc18xLkludmFsaWRSZXNwb25zZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogeyBjb2RlOiAyLCBtZXNzYWdlOiAnQ2h1bmsgdGltZW91dCcgfSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMuY2h1bmtUaW1vdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhbmNlbCB0aW1lb3V0IGFuZCBzZXQgY2h1bmsgdG8gbnVsbFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubGFzdENodW5rVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDaHVuayA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gICAgfVxufVxuZXhwb3J0cy5DaHVua1Jlc3BvbnNlUGFyc2VyID0gQ2h1bmtSZXNwb25zZVBhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rX3Jlc3BvbnNlX3BhcnNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/chunk_response_parser.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/converters.js":
/*!**************************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/converters.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toBool = exports.toChecksumAddress = exports.toWei = exports.fromWei = exports.toBigInt = exports.toNumber = exports.toHex = exports.toAscii = exports.hexToAscii = exports.fromAscii = exports.asciiToHex = exports.hexToString = exports.utf8ToBytes = exports.toUtf8 = exports.hexToUtf8 = exports.stringToHex = exports.fromUtf8 = exports.utf8ToHex = exports.hexToNumberString = exports.fromDecimal = exports.numberToHex = exports.toDecimal = exports.hexToNumber = exports.hexToBytes = exports.bytesToHex = exports.bytesToUint8Array = exports.ethUnitMap = void 0;\n/**\n * @module Utils\n */\nconst keccak_js_1 = __webpack_require__(/*! ethereum-cryptography/keccak.js */ \"(api)/./src/pages/api/node_modules/ethereum-cryptography/keccak.js\");\nconst utils_js_1 = __webpack_require__(/*! ethereum-cryptography/utils.js */ \"(api)/./src/pages/api/node_modules/ethereum-cryptography/utils.js\");\nconst web3_validator_1 = __webpack_require__(/*! web3-validator */ \"(api)/./src/pages/api/node_modules/web3-validator/lib/commonjs/index.js\");\nconst web3_errors_1 = __webpack_require__(/*! web3-errors */ \"(api)/./src/pages/api/node_modules/web3-errors/lib/commonjs/index.js\");\nconst uint8array_js_1 = __webpack_require__(/*! ./uint8array.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/uint8array.js\");\n// Ref: https://ethdocs.org/en/latest/ether.html\n// Note: this could be simplified using ** operator, but babel does not handle it well (https://github.com/babel/babel/issues/13109)\n/** @internal */\nexports.ethUnitMap = {\n    noether: BigInt(0),\n    wei: BigInt(1),\n    kwei: BigInt(1000),\n    Kwei: BigInt(1000),\n    babbage: BigInt(1000),\n    femtoether: BigInt(1000),\n    mwei: BigInt(1000000),\n    Mwei: BigInt(1000000),\n    lovelace: BigInt(1000000),\n    picoether: BigInt(1000000),\n    gwei: BigInt(1000000000),\n    Gwei: BigInt(1000000000),\n    shannon: BigInt(1000000000),\n    nanoether: BigInt(1000000000),\n    nano: BigInt(1000000000),\n    szabo: BigInt(1000000000000),\n    microether: BigInt(1000000000000),\n    micro: BigInt(1000000000000),\n    finney: BigInt(1000000000000000),\n    milliether: BigInt(1000000000000000),\n    milli: BigInt(1000000000000000),\n    ether: BigInt('1000000000000000000'),\n    kether: BigInt('1000000000000000000000'),\n    grand: BigInt('1000000000000000000000'),\n    mether: BigInt('1000000000000000000000000'),\n    gether: BigInt('1000000000000000000000000000'),\n    tether: BigInt('1000000000000000000000000000000'),\n};\n/**\n * Convert a value from bytes to Uint8Array\n * @param data - Data to be converted\n * @returns - The Uint8Array representation of the input data\n *\n * @example\n * ```ts\n * console.log(web3.utils.bytesToUint8Array(\"0xab\")));\n * > Uint8Array(1) [ 171 ]\n * ```\n */\nconst bytesToUint8Array = (data) => {\n    web3_validator_1.validator.validate(['bytes'], [data]);\n    if ((0, uint8array_js_1.isUint8Array)(data)) {\n        return data;\n    }\n    if (Array.isArray(data)) {\n        return new Uint8Array(data);\n    }\n    if (typeof data === 'string') {\n        return web3_validator_1.utils.hexToUint8Array(data);\n    }\n    throw new web3_errors_1.InvalidBytesError(data);\n};\nexports.bytesToUint8Array = bytesToUint8Array;\n/**\n * @internal\n */\nconst { uint8ArrayToHexString } = web3_validator_1.utils;\n/**\n * Convert a byte array to a hex string\n * @param bytes - Byte array to be converted\n * @returns - The hex string representation of the input byte array\n *\n * @example\n * ```ts\n * console.log(web3.utils.bytesToHex(new Uint8Array([72, 12])));\n * > \"0x480c\"\n *\n */\nconst bytesToHex = (bytes) => uint8ArrayToHexString((0, exports.bytesToUint8Array)(bytes));\nexports.bytesToHex = bytesToHex;\n/**\n * Convert a hex string to a byte array\n * @param hex - Hex string to be converted\n * @returns - The byte array representation of the input hex string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToBytes('0x74657374'));\n * > Uint8Array(4) [ 116, 101, 115, 116 ]\n * ```\n */\nconst hexToBytes = (bytes) => {\n    if (typeof bytes === 'string' && bytes.slice(0, 2).toLowerCase() !== '0x') {\n        return (0, exports.bytesToUint8Array)(`0x${bytes}`);\n    }\n    return (0, exports.bytesToUint8Array)(bytes);\n};\nexports.hexToBytes = hexToBytes;\n/**\n * Converts value to it's number representation\n * @param value - Hex string to be converted\n * @returns - The number representation of the input value\n *\n * @example\n * ```ts\n * conoslle.log(web3.utils.hexToNumber('0xa'));\n * > 10\n * ```\n */\nconst hexToNumber = (value) => {\n    web3_validator_1.validator.validate(['hex'], [value]);\n    // To avoid duplicate code and circular dependency we will\n    // use `hexToNumber` implementation from `web3-validator`\n    return web3_validator_1.utils.hexToNumber(value);\n};\nexports.hexToNumber = hexToNumber;\n/**\n * Converts value to it's number representation @alias `hexToNumber`\n */\nexports.toDecimal = exports.hexToNumber;\n/**\n * Converts value to it's hex representation\n * @param value - Value to be converted\n * @param hexstrict - Add padding to converted value if odd, to make it hexstrict\n * @returns - The hex representation of the input value\n *\n * @example\n * ```ts\n * console.log(web3.utils.numberToHex(10));\n * > \"0xa\"\n * ```\n */\nconst numberToHex = (value, hexstrict) => {\n    if (typeof value !== 'bigint')\n        web3_validator_1.validator.validate(['int'], [value]);\n    // To avoid duplicate code and circular dependency we will\n    // use `numberToHex` implementation from `web3-validator`\n    let updatedValue = web3_validator_1.utils.numberToHex(value);\n    if (hexstrict) {\n        if (!updatedValue.startsWith('-') && updatedValue.length % 2 === 1) {\n            // To avoid duplicate a circular dependancy we will not be using the padLeft method\n            updatedValue = '0x0'.concat(updatedValue.slice(2));\n        }\n        else if (updatedValue.length % 2 === 0 && updatedValue.startsWith('-'))\n            updatedValue = '-0x0'.concat(updatedValue.slice(3));\n    }\n    return updatedValue;\n};\nexports.numberToHex = numberToHex;\n/**\n * Converts value to it's hex representation @alias `numberToHex`\n *\n */\nexports.fromDecimal = exports.numberToHex;\n/**\n * Converts value to it's decimal representation in string\n * @param value - Hex string to be converted\n * @returns - The decimal representation of the input value\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToNumberString('0xa'));\n * > \"10\"\n * ```\n */\nconst hexToNumberString = (data) => (0, exports.hexToNumber)(data).toString();\nexports.hexToNumberString = hexToNumberString;\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n * @param str - Utf8 string to be converted\n * @returns - The hex representation of the input string\n *\n * @example\n * ```ts\n * console.log(utf8ToHex('web3.js'));\n * > \"0x776562332e6a73\"\n * ```\n *\n */\nconst utf8ToHex = (str) => {\n    web3_validator_1.validator.validate(['string'], [str]);\n    // To be compatible with 1.x trim null character\n    // eslint-disable-next-line no-control-regex\n    let strWithoutNullCharacter = str.replace(/^(?:\\u0000)/, '');\n    // eslint-disable-next-line no-control-regex\n    strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\\u0000)$/, '');\n    return (0, exports.bytesToHex)(new TextEncoder().encode(strWithoutNullCharacter));\n};\nexports.utf8ToHex = utf8ToHex;\n/**\n * @alias utf8ToHex\n */\nexports.fromUtf8 = exports.utf8ToHex;\n/**\n * @alias utf8ToHex\n */\nexports.stringToHex = exports.utf8ToHex;\n/**\n * Should be called to get utf8 from it's hex representation\n * @param str - Hex string to be converted\n * @returns - Utf8 string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToUtf8('0x48656c6c6f20576f726c64'));\n * > Hello World\n * ```\n */\nconst hexToUtf8 = (str) => (0, utils_js_1.bytesToUtf8)((0, exports.hexToBytes)(str));\nexports.hexToUtf8 = hexToUtf8;\n/**\n * @alias hexToUtf8\n */\nconst toUtf8 = (input) => {\n    if (typeof input === 'string') {\n        return (0, exports.hexToUtf8)(input);\n    }\n    web3_validator_1.validator.validate(['bytes'], [input]);\n    return (0, utils_js_1.bytesToUtf8)(input);\n};\nexports.toUtf8 = toUtf8;\nexports.utf8ToBytes = utils_js_1.utf8ToBytes;\n/**\n * @alias hexToUtf8\n */\nexports.hexToString = exports.hexToUtf8;\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n * @param str - String to be converted to hex\n * @returns - Hex string\n *\n * @example\n * ```ts\n * console.log(web3.utils.asciiToHex('Hello World'));\n * > 0x48656c6c6f20576f726c64\n * ```\n */\nconst asciiToHex = (str) => {\n    web3_validator_1.validator.validate(['string'], [str]);\n    let hexString = '';\n    for (let i = 0; i < str.length; i += 1) {\n        const hexCharCode = str.charCodeAt(i).toString(16);\n        // might need a leading 0\n        hexString += hexCharCode.length % 2 !== 0 ? `0${hexCharCode}` : hexCharCode;\n    }\n    return `0x${hexString}`;\n};\nexports.asciiToHex = asciiToHex;\n/**\n * @alias asciiToHex\n */\nexports.fromAscii = exports.asciiToHex;\n/**\n * Should be called to get ascii from it's hex representation\n * @param str - Hex string to be converted to ascii\n * @returns - Ascii string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToAscii('0x48656c6c6f20576f726c64'));\n * > Hello World\n * ```\n */\nconst hexToAscii = (str) => {\n    const decoder = new TextDecoder('ascii');\n    return decoder.decode((0, exports.hexToBytes)(str));\n};\nexports.hexToAscii = hexToAscii;\n/**\n * @alias hexToAscii\n */\nexports.toAscii = exports.hexToAscii;\n/**\n * Auto converts any given value into it's hex representation.\n * @param value - Value to be converted to hex\n * @param returnType - If true, it will return the type of the value\n *\n * @example\n * ```ts\n * console.log(web3.utils.toHex(10));\n * > 0xa\n *\n * console.log(web3.utils.toHex('0x123', true));\n * > bytes\n *```\n */\nconst toHex = (value, returnType) => {\n    if (typeof value === 'string' && (0, web3_validator_1.isAddress)(value)) {\n        return returnType ? 'address' : `0x${value.toLowerCase().replace(/^0x/i, '')}`;\n    }\n    if (typeof value === 'boolean') {\n        // eslint-disable-next-line no-nested-ternary\n        return returnType ? 'bool' : value ? '0x01' : '0x00';\n    }\n    if (typeof value === 'number') {\n        // eslint-disable-next-line no-nested-ternary\n        return returnType ? (value < 0 ? 'int256' : 'uint256') : (0, exports.numberToHex)(value);\n    }\n    if (typeof value === 'bigint') {\n        return returnType ? 'bigint' : (0, exports.numberToHex)(value);\n    }\n    if (typeof value === 'object' && !!value) {\n        return returnType ? 'string' : (0, exports.utf8ToHex)(JSON.stringify(value));\n    }\n    if (typeof value === 'string') {\n        if (value.startsWith('-0x') || value.startsWith('-0X')) {\n            return returnType ? 'int256' : (0, exports.numberToHex)(value);\n        }\n        if ((0, web3_validator_1.isHexStrict)(value)) {\n            return returnType ? 'bytes' : value;\n        }\n        if ((0, web3_validator_1.isHex)(value) && !(0, web3_validator_1.isInt)(value) && !(0, web3_validator_1.isUInt)(value)) {\n            return returnType ? 'bytes' : `0x${value}`;\n        }\n        if ((0, web3_validator_1.isHex)(value) && !(0, web3_validator_1.isInt)(value) && (0, web3_validator_1.isUInt)(value)) {\n            return returnType ? 'uint' : (0, exports.numberToHex)(value);\n        }\n        if (!Number.isFinite(value)) {\n            return returnType ? 'string' : (0, exports.utf8ToHex)(value);\n        }\n    }\n    throw new web3_errors_1.HexProcessingError(value);\n};\nexports.toHex = toHex;\n/**\n * Converts any given value into it's number representation, if possible, else into it's bigint representation.\n * @param value - The value to convert\n * @returns - Returns the value in number or bigint representation\n *\n * @example\n * ```ts\n * console.log(web3.utils.toNumber(1));\n * > 1\n * console.log(web3.utils.toNumber(Number.MAX_SAFE_INTEGER));\n * > 9007199254740991\n *\n * console.log(web3.utils.toNumber(BigInt(Number.MAX_SAFE_INTEGER)));\n * > 9007199254740991\n *\n * console.log(web3.utils.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)));\n * > 9007199254740992n\n *\n * ```\n */\nconst toNumber = (value) => {\n    if (typeof value === 'number') {\n        return value;\n    }\n    if (typeof value === 'bigint') {\n        return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER\n            ? Number(value)\n            : value;\n    }\n    if (typeof value === 'string' && (0, web3_validator_1.isHexStrict)(value)) {\n        return (0, exports.hexToNumber)(value);\n    }\n    try {\n        return (0, exports.toNumber)(BigInt(value));\n    }\n    catch (_a) {\n        throw new web3_errors_1.InvalidNumberError(value);\n    }\n};\nexports.toNumber = toNumber;\n/**\n * Auto converts any given value into it's bigint representation\n *\n * @param value - The value to convert\n * @returns - Returns the value in bigint representation\n\n * @example\n * ```ts\n * console.log(web3.utils.toBigInt(1));\n * > 1n\n * ```\n */\nconst toBigInt = (value) => {\n    if (typeof value === 'number') {\n        return BigInt(value);\n    }\n    if (typeof value === 'bigint') {\n        return value;\n    }\n    // isHex passes for dec, too\n    if (typeof value === 'string' && (0, web3_validator_1.isHex)(value)) {\n        if (value.startsWith('-')) {\n            return -BigInt(value.substring(1));\n        }\n        return BigInt(value);\n    }\n    throw new web3_errors_1.InvalidNumberError(value);\n};\nexports.toBigInt = toBigInt;\n/**\n * Takes a number of wei and converts it to any other ether unit.\n * @param number - The value in wei\n * @param unit - The unit to convert to\n * @returns - Returns the converted value in the given unit\n *\n * @example\n * ```ts\n * console.log(web3.utils.fromWei(\"1\", \"ether\"));\n * > 0.000000000000000001\n *\n * console.log(web3.utils.fromWei(\"1\", \"shannon\"));\n * > 0.000000001\n * ```\n */\nconst fromWei = (number, unit) => {\n    const denomination = exports.ethUnitMap[unit];\n    if (!denomination) {\n        throw new web3_errors_1.InvalidUnitError(unit);\n    }\n    // value in wei would always be integer\n    // 13456789, 1234\n    const value = String((0, exports.toNumber)(number));\n    // count number of zeros in denomination\n    // 1000000 -> 6\n    const numberOfZerosInDenomination = denomination.toString().length - 1;\n    if (numberOfZerosInDenomination <= 0) {\n        return value.toString();\n    }\n    // pad the value with required zeros\n    // 13456789 -> 13456789, 1234 -> 001234\n    const zeroPaddedValue = value.padStart(numberOfZerosInDenomination, '0');\n    // get the integer part of value by counting number of zeros from start\n    // 13456789 -> '13'\n    // 001234 -> ''\n    const integer = zeroPaddedValue.slice(0, -numberOfZerosInDenomination);\n    // get the fraction part of value by counting number of zeros backward\n    // 13456789 -> '456789'\n    // 001234 -> '001234'\n    const fraction = zeroPaddedValue.slice(-numberOfZerosInDenomination).replace(/\\.?0+$/, '');\n    if (integer === '') {\n        return `0.${fraction}`;\n    }\n    if (fraction === '') {\n        return integer;\n    }\n    return `${integer}.${fraction}`;\n};\nexports.fromWei = fromWei;\n/**\n * Takes a number of a unit and converts it to wei.\n *\n * @param number - The number to convert.\n * @param unit - {@link EtherUnits} The unit of the number passed.\n * @returns The number converted to wei.\n *\n * @example\n * ```ts\n * console.log(web3.utils.toWei(\"0.001\", \"ether\"));\n * > 1000000000000000 //(wei)\n * ```\n */\n// todo in 1.x unit defaults to 'ether'\nconst toWei = (number, unit) => {\n    web3_validator_1.validator.validate(['number'], [number]);\n    const denomination = exports.ethUnitMap[unit];\n    if (!denomination) {\n        throw new web3_errors_1.InvalidUnitError(unit);\n    }\n    // if value is decimal e.g. 24.56 extract `integer` and `fraction` part\n    // to avoid `fraction` to be null use `concat` with empty string\n    const [integer, fraction] = String(typeof number === 'string' && !(0, web3_validator_1.isHexStrict)(number) ? number : (0, exports.toNumber)(number))\n        .split('.')\n        .concat('');\n    // join the value removing `.` from\n    // 24.56 -> 2456\n    const value = BigInt(`${integer}${fraction}`);\n    // multiply value with denomination\n    // 2456 * 1000000 -> 2456000000\n    const updatedValue = value * denomination;\n    // count number of zeros in denomination\n    const numberOfZerosInDenomination = denomination.toString().length - 1;\n    // check which either `fraction` or `denomination` have lower number of zeros\n    const decimals = Math.min(fraction.length, numberOfZerosInDenomination);\n    if (decimals === 0) {\n        return updatedValue.toString();\n    }\n    // Add zeros to make length equal to required decimal points\n    // If string is larger than decimal points required then remove last zeros\n    return updatedValue.toString().padStart(decimals, '0').slice(0, -decimals);\n};\nexports.toWei = toWei;\n/**\n * Will convert an upper or lowercase Ethereum address to a checksum address.\n * @param address - An address string\n * @returns\tThe checksum address\n * @example\n * ```ts\n * web3.utils.toChecksumAddress('0xc1912fee45d61c87cc5ea59dae31190fffff232d');\n * > \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\"\n * ```\n */\nconst toChecksumAddress = (address) => {\n    if (!(0, web3_validator_1.isAddress)(address, false)) {\n        throw new web3_errors_1.InvalidAddressError(address);\n    }\n    const lowerCaseAddress = address.toLowerCase().replace(/^0x/i, '');\n    // calling `Uint8Array.from` because `noble-hashes` checks with `instanceof Uint8Array` that fails in some edge cases:\n    // \thttps://github.com/paulmillr/noble-hashes/issues/25#issuecomment-1750106284\n    const hash = web3_validator_1.utils.uint8ArrayToHexString((0, keccak_js_1.keccak256)(web3_validator_1.utils.ensureIfUint8Array((0, exports.utf8ToBytes)(lowerCaseAddress))));\n    if ((0, web3_validator_1.isNullish)(hash) ||\n        hash === '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470')\n        return ''; // // EIP-1052 if hash is equal to c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, keccak was given empty data\n    let checksumAddress = '0x';\n    const addressHash = hash.replace(/^0x/i, '');\n    for (let i = 0; i < lowerCaseAddress.length; i += 1) {\n        // If ith character is 8 to f then make it uppercase\n        if (parseInt(addressHash[i], 16) > 7) {\n            checksumAddress += lowerCaseAddress[i].toUpperCase();\n        }\n        else {\n            checksumAddress += lowerCaseAddress[i];\n        }\n    }\n    return checksumAddress;\n};\nexports.toChecksumAddress = toChecksumAddress;\nconst toBool = (value) => {\n    if (typeof value === 'boolean') {\n        return value;\n    }\n    if (typeof value === 'number' && (value === 0 || value === 1)) {\n        return Boolean(value);\n    }\n    if (typeof value === 'bigint' && (value === BigInt(0) || value === BigInt(1))) {\n        return Boolean(value);\n    }\n    if (typeof value === 'string' &&\n        !(0, web3_validator_1.isHexStrict)(value) &&\n        (value === '1' || value === '0' || value === 'false' || value === 'true')) {\n        if (value === 'true') {\n            return true;\n        }\n        if (value === 'false') {\n            return false;\n        }\n        return Boolean(Number(value));\n    }\n    if (typeof value === 'string' && (0, web3_validator_1.isHexStrict)(value) && (value === '0x1' || value === '0x0')) {\n        return Boolean((0, exports.toNumber)(value));\n    }\n    throw new web3_errors_1.InvalidBooleanError(value);\n};\nexports.toBool = toBool;\n//# sourceMappingURL=converters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9jb252ZXJ0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcseUJBQXlCLEdBQUcsYUFBYSxHQUFHLGVBQWUsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxhQUFhLEdBQUcsZUFBZSxHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLGNBQWMsR0FBRyxpQkFBaUIsR0FBRyxtQkFBbUIsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUIsR0FBRyx5QkFBeUIsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRyxrQkFBa0I7QUFDN2lCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLDJHQUFpQztBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQyx5R0FBZ0M7QUFDM0QseUJBQXlCLG1CQUFPLENBQUMsK0ZBQWdCO0FBQ2pELHNCQUFzQixtQkFBTyxDQUFDLHlGQUFhO0FBQzNDLHdCQUF3QixtQkFBTyxDQUFDLGlHQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3QkFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE1BQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx3Q0FBd0M7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUSxHQUFHLFNBQVM7QUFDbEM7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsRUFBRSxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXNzdWVyX2hvbGRlcl92ZXJpZmllci8uL3NyYy9wYWdlcy9hcGkvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL2NvbW1vbmpzL2NvbnZlcnRlcnMuanM/YTg0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG5UaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG53ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbml0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxudGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbihhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbndlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbmJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG5NRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG5HTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG5hbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b0Jvb2wgPSBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZXhwb3J0cy50b1dlaSA9IGV4cG9ydHMuZnJvbVdlaSA9IGV4cG9ydHMudG9CaWdJbnQgPSBleHBvcnRzLnRvTnVtYmVyID0gZXhwb3J0cy50b0hleCA9IGV4cG9ydHMudG9Bc2NpaSA9IGV4cG9ydHMuaGV4VG9Bc2NpaSA9IGV4cG9ydHMuZnJvbUFzY2lpID0gZXhwb3J0cy5hc2NpaVRvSGV4ID0gZXhwb3J0cy5oZXhUb1N0cmluZyA9IGV4cG9ydHMudXRmOFRvQnl0ZXMgPSBleHBvcnRzLnRvVXRmOCA9IGV4cG9ydHMuaGV4VG9VdGY4ID0gZXhwb3J0cy5zdHJpbmdUb0hleCA9IGV4cG9ydHMuZnJvbVV0ZjggPSBleHBvcnRzLnV0ZjhUb0hleCA9IGV4cG9ydHMuaGV4VG9OdW1iZXJTdHJpbmcgPSBleHBvcnRzLmZyb21EZWNpbWFsID0gZXhwb3J0cy5udW1iZXJUb0hleCA9IGV4cG9ydHMudG9EZWNpbWFsID0gZXhwb3J0cy5oZXhUb051bWJlciA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuYnl0ZXNUb1VpbnQ4QXJyYXkgPSBleHBvcnRzLmV0aFVuaXRNYXAgPSB2b2lkIDA7XG4vKipcbiAqIEBtb2R1bGUgVXRpbHNcbiAqL1xuY29uc3Qga2VjY2FrX2pzXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3V0aWxzLmpzXCIpO1xuY29uc3Qgd2ViM192YWxpZGF0b3JfMSA9IHJlcXVpcmUoXCJ3ZWIzLXZhbGlkYXRvclwiKTtcbmNvbnN0IHdlYjNfZXJyb3JzXzEgPSByZXF1aXJlKFwid2ViMy1lcnJvcnNcIik7XG5jb25zdCB1aW50OGFycmF5X2pzXzEgPSByZXF1aXJlKFwiLi91aW50OGFycmF5LmpzXCIpO1xuLy8gUmVmOiBodHRwczovL2V0aGRvY3Mub3JnL2VuL2xhdGVzdC9ldGhlci5odG1sXG4vLyBOb3RlOiB0aGlzIGNvdWxkIGJlIHNpbXBsaWZpZWQgdXNpbmcgKiogb3BlcmF0b3IsIGJ1dCBiYWJlbCBkb2VzIG5vdCBoYW5kbGUgaXQgd2VsbCAoaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2lzc3Vlcy8xMzEwOSlcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydHMuZXRoVW5pdE1hcCA9IHtcbiAgICBub2V0aGVyOiBCaWdJbnQoMCksXG4gICAgd2VpOiBCaWdJbnQoMSksXG4gICAga3dlaTogQmlnSW50KDEwMDApLFxuICAgIEt3ZWk6IEJpZ0ludCgxMDAwKSxcbiAgICBiYWJiYWdlOiBCaWdJbnQoMTAwMCksXG4gICAgZmVtdG9ldGhlcjogQmlnSW50KDEwMDApLFxuICAgIG13ZWk6IEJpZ0ludCgxMDAwMDAwKSxcbiAgICBNd2VpOiBCaWdJbnQoMTAwMDAwMCksXG4gICAgbG92ZWxhY2U6IEJpZ0ludCgxMDAwMDAwKSxcbiAgICBwaWNvZXRoZXI6IEJpZ0ludCgxMDAwMDAwKSxcbiAgICBnd2VpOiBCaWdJbnQoMTAwMDAwMDAwMCksXG4gICAgR3dlaTogQmlnSW50KDEwMDAwMDAwMDApLFxuICAgIHNoYW5ub246IEJpZ0ludCgxMDAwMDAwMDAwKSxcbiAgICBuYW5vZXRoZXI6IEJpZ0ludCgxMDAwMDAwMDAwKSxcbiAgICBuYW5vOiBCaWdJbnQoMTAwMDAwMDAwMCksXG4gICAgc3phYm86IEJpZ0ludCgxMDAwMDAwMDAwMDAwKSxcbiAgICBtaWNyb2V0aGVyOiBCaWdJbnQoMTAwMDAwMDAwMDAwMCksXG4gICAgbWljcm86IEJpZ0ludCgxMDAwMDAwMDAwMDAwKSxcbiAgICBmaW5uZXk6IEJpZ0ludCgxMDAwMDAwMDAwMDAwMDAwKSxcbiAgICBtaWxsaWV0aGVyOiBCaWdJbnQoMTAwMDAwMDAwMDAwMDAwMCksXG4gICAgbWlsbGk6IEJpZ0ludCgxMDAwMDAwMDAwMDAwMDAwKSxcbiAgICBldGhlcjogQmlnSW50KCcxMDAwMDAwMDAwMDAwMDAwMDAwJyksXG4gICAga2V0aGVyOiBCaWdJbnQoJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKSxcbiAgICBncmFuZDogQmlnSW50KCcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyksXG4gICAgbWV0aGVyOiBCaWdJbnQoJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKSxcbiAgICBnZXRoZXI6IEJpZ0ludCgnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpLFxuICAgIHRldGhlcjogQmlnSW50KCcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyksXG59O1xuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgZnJvbSBieXRlcyB0byBVaW50OEFycmF5XG4gKiBAcGFyYW0gZGF0YSAtIERhdGEgdG8gYmUgY29udmVydGVkXG4gKiBAcmV0dXJucyAtIFRoZSBVaW50OEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnB1dCBkYXRhXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zb2xlLmxvZyh3ZWIzLnV0aWxzLmJ5dGVzVG9VaW50OEFycmF5KFwiMHhhYlwiKSkpO1xuICogPiBVaW50OEFycmF5KDEpIFsgMTcxIF1cbiAqIGBgYFxuICovXG5jb25zdCBieXRlc1RvVWludDhBcnJheSA9IChkYXRhKSA9PiB7XG4gICAgd2ViM192YWxpZGF0b3JfMS52YWxpZGF0b3IudmFsaWRhdGUoWydieXRlcyddLCBbZGF0YV0pO1xuICAgIGlmICgoMCwgdWludDhhcnJheV9qc18xLmlzVWludDhBcnJheSkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gd2ViM192YWxpZGF0b3JfMS51dGlscy5oZXhUb1VpbnQ4QXJyYXkoZGF0YSk7XG4gICAgfVxuICAgIHRocm93IG5ldyB3ZWIzX2Vycm9yc18xLkludmFsaWRCeXRlc0Vycm9yKGRhdGEpO1xufTtcbmV4cG9ydHMuYnl0ZXNUb1VpbnQ4QXJyYXkgPSBieXRlc1RvVWludDhBcnJheTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IHsgdWludDhBcnJheVRvSGV4U3RyaW5nIH0gPSB3ZWIzX3ZhbGlkYXRvcl8xLnV0aWxzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGhleCBzdHJpbmdcbiAqIEBwYXJhbSBieXRlcyAtIEJ5dGUgYXJyYXkgdG8gYmUgY29udmVydGVkXG4gKiBAcmV0dXJucyAtIFRoZSBoZXggc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnB1dCBieXRlIGFycmF5XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zb2xlLmxvZyh3ZWIzLnV0aWxzLmJ5dGVzVG9IZXgobmV3IFVpbnQ4QXJyYXkoWzcyLCAxMl0pKSk7XG4gKiA+IFwiMHg0ODBjXCJcbiAqXG4gKi9cbmNvbnN0IGJ5dGVzVG9IZXggPSAoYnl0ZXMpID0+IHVpbnQ4QXJyYXlUb0hleFN0cmluZygoMCwgZXhwb3J0cy5ieXRlc1RvVWludDhBcnJheSkoYnl0ZXMpKTtcbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBoZXggc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICogQHBhcmFtIGhleCAtIEhleCBzdHJpbmcgdG8gYmUgY29udmVydGVkXG4gKiBAcmV0dXJucyAtIFRoZSBieXRlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnB1dCBoZXggc3RyaW5nXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zb2xlLmxvZyh3ZWIzLnV0aWxzLmhleFRvQnl0ZXMoJzB4NzQ2NTczNzQnKSk7XG4gKiA+IFVpbnQ4QXJyYXkoNCkgWyAxMTYsIDEwMSwgMTE1LCAxMTYgXVxuICogYGBgXG4gKi9cbmNvbnN0IGhleFRvQnl0ZXMgPSAoYnl0ZXMpID0+IHtcbiAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJyAmJiBieXRlcy5zbGljZSgwLCAyKS50b0xvd2VyQ2FzZSgpICE9PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5ieXRlc1RvVWludDhBcnJheSkoYDB4JHtieXRlc31gKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmJ5dGVzVG9VaW50OEFycmF5KShieXRlcyk7XG59O1xuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8qKlxuICogQ29udmVydHMgdmFsdWUgdG8gaXQncyBudW1iZXIgcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSB2YWx1ZSAtIEhleCBzdHJpbmcgdG8gYmUgY29udmVydGVkXG4gKiBAcmV0dXJucyAtIFRoZSBudW1iZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGlucHV0IHZhbHVlXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25vc2xsZS5sb2cod2ViMy51dGlscy5oZXhUb051bWJlcignMHhhJykpO1xuICogPiAxMFxuICogYGBgXG4gKi9cbmNvbnN0IGhleFRvTnVtYmVyID0gKHZhbHVlKSA9PiB7XG4gICAgd2ViM192YWxpZGF0b3JfMS52YWxpZGF0b3IudmFsaWRhdGUoWydoZXgnXSwgW3ZhbHVlXSk7XG4gICAgLy8gVG8gYXZvaWQgZHVwbGljYXRlIGNvZGUgYW5kIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2Ugd2lsbFxuICAgIC8vIHVzZSBgaGV4VG9OdW1iZXJgIGltcGxlbWVudGF0aW9uIGZyb20gYHdlYjMtdmFsaWRhdG9yYFxuICAgIHJldHVybiB3ZWIzX3ZhbGlkYXRvcl8xLnV0aWxzLmhleFRvTnVtYmVyKHZhbHVlKTtcbn07XG5leHBvcnRzLmhleFRvTnVtYmVyID0gaGV4VG9OdW1iZXI7XG4vKipcbiAqIENvbnZlcnRzIHZhbHVlIHRvIGl0J3MgbnVtYmVyIHJlcHJlc2VudGF0aW9uIEBhbGlhcyBgaGV4VG9OdW1iZXJgXG4gKi9cbmV4cG9ydHMudG9EZWNpbWFsID0gZXhwb3J0cy5oZXhUb051bWJlcjtcbi8qKlxuICogQ29udmVydHMgdmFsdWUgdG8gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGNvbnZlcnRlZFxuICogQHBhcmFtIGhleHN0cmljdCAtIEFkZCBwYWRkaW5nIHRvIGNvbnZlcnRlZCB2YWx1ZSBpZiBvZGQsIHRvIG1ha2UgaXQgaGV4c3RyaWN0XG4gKiBAcmV0dXJucyAtIFRoZSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGlucHV0IHZhbHVlXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zb2xlLmxvZyh3ZWIzLnV0aWxzLm51bWJlclRvSGV4KDEwKSk7XG4gKiA+IFwiMHhhXCJcbiAqIGBgYFxuICovXG5jb25zdCBudW1iZXJUb0hleCA9ICh2YWx1ZSwgaGV4c3RyaWN0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHdlYjNfdmFsaWRhdG9yXzEudmFsaWRhdG9yLnZhbGlkYXRlKFsnaW50J10sIFt2YWx1ZV0pO1xuICAgIC8vIFRvIGF2b2lkIGR1cGxpY2F0ZSBjb2RlIGFuZCBjaXJjdWxhciBkZXBlbmRlbmN5IHdlIHdpbGxcbiAgICAvLyB1c2UgYG51bWJlclRvSGV4YCBpbXBsZW1lbnRhdGlvbiBmcm9tIGB3ZWIzLXZhbGlkYXRvcmBcbiAgICBsZXQgdXBkYXRlZFZhbHVlID0gd2ViM192YWxpZGF0b3JfMS51dGlscy5udW1iZXJUb0hleCh2YWx1ZSk7XG4gICAgaWYgKGhleHN0cmljdCkge1xuICAgICAgICBpZiAoIXVwZGF0ZWRWYWx1ZS5zdGFydHNXaXRoKCctJykgJiYgdXBkYXRlZFZhbHVlLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIFRvIGF2b2lkIGR1cGxpY2F0ZSBhIGNpcmN1bGFyIGRlcGVuZGFuY3kgd2Ugd2lsbCBub3QgYmUgdXNpbmcgdGhlIHBhZExlZnQgbWV0aG9kXG4gICAgICAgICAgICB1cGRhdGVkVmFsdWUgPSAnMHgwJy5jb25jYXQodXBkYXRlZFZhbHVlLnNsaWNlKDIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1cGRhdGVkVmFsdWUubGVuZ3RoICUgMiA9PT0gMCAmJiB1cGRhdGVkVmFsdWUuc3RhcnRzV2l0aCgnLScpKVxuICAgICAgICAgICAgdXBkYXRlZFZhbHVlID0gJy0weDAnLmNvbmNhdCh1cGRhdGVkVmFsdWUuc2xpY2UoMykpO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlZFZhbHVlO1xufTtcbmV4cG9ydHMubnVtYmVyVG9IZXggPSBudW1iZXJUb0hleDtcbi8qKlxuICogQ29udmVydHMgdmFsdWUgdG8gaXQncyBoZXggcmVwcmVzZW50YXRpb24gQGFsaWFzIGBudW1iZXJUb0hleGBcbiAqXG4gKi9cbmV4cG9ydHMuZnJvbURlY2ltYWwgPSBleHBvcnRzLm51bWJlclRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0cyB2YWx1ZSB0byBpdCdzIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gaW4gc3RyaW5nXG4gKiBAcGFyYW0gdmFsdWUgLSBIZXggc3RyaW5nIHRvIGJlIGNvbnZlcnRlZFxuICogQHJldHVybnMgLSBUaGUgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5wdXQgdmFsdWVcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMuaGV4VG9OdW1iZXJTdHJpbmcoJzB4YScpKTtcbiAqID4gXCIxMFwiXG4gKiBgYGBcbiAqL1xuY29uc3QgaGV4VG9OdW1iZXJTdHJpbmcgPSAoZGF0YSkgPT4gKDAsIGV4cG9ydHMuaGV4VG9OdW1iZXIpKGRhdGEpLnRvU3RyaW5nKCk7XG5leHBvcnRzLmhleFRvTnVtYmVyU3RyaW5nID0gaGV4VG9OdW1iZXJTdHJpbmc7XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKiBAcGFyYW0gc3RyIC0gVXRmOCBzdHJpbmcgdG8gYmUgY29udmVydGVkXG4gKiBAcmV0dXJucyAtIFRoZSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGlucHV0IHN0cmluZ1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc29sZS5sb2codXRmOFRvSGV4KCd3ZWIzLmpzJykpO1xuICogPiBcIjB4Nzc2NTYyMzMyZTZhNzNcIlxuICogYGBgXG4gKlxuICovXG5jb25zdCB1dGY4VG9IZXggPSAoc3RyKSA9PiB7XG4gICAgd2ViM192YWxpZGF0b3JfMS52YWxpZGF0b3IudmFsaWRhdGUoWydzdHJpbmcnXSwgW3N0cl0pO1xuICAgIC8vIFRvIGJlIGNvbXBhdGlibGUgd2l0aCAxLnggdHJpbSBudWxsIGNoYXJhY3RlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgbGV0IHN0cldpdGhvdXROdWxsQ2hhcmFjdGVyID0gc3RyLnJlcGxhY2UoL14oPzpcXHUwMDAwKS8sICcnKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgIHN0cldpdGhvdXROdWxsQ2hhcmFjdGVyID0gc3RyV2l0aG91dE51bGxDaGFyYWN0ZXIucmVwbGFjZSgvKD86XFx1MDAwMCkkLywgJycpO1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5ieXRlc1RvSGV4KShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyV2l0aG91dE51bGxDaGFyYWN0ZXIpKTtcbn07XG5leHBvcnRzLnV0ZjhUb0hleCA9IHV0ZjhUb0hleDtcbi8qKlxuICogQGFsaWFzIHV0ZjhUb0hleFxuICovXG5leHBvcnRzLmZyb21VdGY4ID0gZXhwb3J0cy51dGY4VG9IZXg7XG4vKipcbiAqIEBhbGlhcyB1dGY4VG9IZXhcbiAqL1xuZXhwb3J0cy5zdHJpbmdUb0hleCA9IGV4cG9ydHMudXRmOFRvSGV4O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCB1dGY4IGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSBzdHIgLSBIZXggc3RyaW5nIHRvIGJlIGNvbnZlcnRlZFxuICogQHJldHVybnMgLSBVdGY4IHN0cmluZ1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc29sZS5sb2cod2ViMy51dGlscy5oZXhUb1V0ZjgoJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NCcpKTtcbiAqID4gSGVsbG8gV29ybGRcbiAqIGBgYFxuICovXG5jb25zdCBoZXhUb1V0ZjggPSAoc3RyKSA9PiAoMCwgdXRpbHNfanNfMS5ieXRlc1RvVXRmOCkoKDAsIGV4cG9ydHMuaGV4VG9CeXRlcykoc3RyKSk7XG5leHBvcnRzLmhleFRvVXRmOCA9IGhleFRvVXRmODtcbi8qKlxuICogQGFsaWFzIGhleFRvVXRmOFxuICovXG5jb25zdCB0b1V0ZjggPSAoaW5wdXQpID0+IHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuaGV4VG9VdGY4KShpbnB1dCk7XG4gICAgfVxuICAgIHdlYjNfdmFsaWRhdG9yXzEudmFsaWRhdG9yLnZhbGlkYXRlKFsnYnl0ZXMnXSwgW2lucHV0XSk7XG4gICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmJ5dGVzVG9VdGY4KShpbnB1dCk7XG59O1xuZXhwb3J0cy50b1V0ZjggPSB0b1V0Zjg7XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRpbHNfanNfMS51dGY4VG9CeXRlcztcbi8qKlxuICogQGFsaWFzIGhleFRvVXRmOFxuICovXG5leHBvcnRzLmhleFRvU3RyaW5nID0gZXhwb3J0cy5oZXhUb1V0Zjg7XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byBiZSBjb252ZXJ0ZWQgdG8gaGV4XG4gKiBAcmV0dXJucyAtIEhleCBzdHJpbmdcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMuYXNjaWlUb0hleCgnSGVsbG8gV29ybGQnKSk7XG4gKiA+IDB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NFxuICogYGBgXG4gKi9cbmNvbnN0IGFzY2lpVG9IZXggPSAoc3RyKSA9PiB7XG4gICAgd2ViM192YWxpZGF0b3JfMS52YWxpZGF0b3IudmFsaWRhdGUoWydzdHJpbmcnXSwgW3N0cl0pO1xuICAgIGxldCBoZXhTdHJpbmcgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBoZXhDaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgLy8gbWlnaHQgbmVlZCBhIGxlYWRpbmcgMFxuICAgICAgICBoZXhTdHJpbmcgKz0gaGV4Q2hhckNvZGUubGVuZ3RoICUgMiAhPT0gMCA/IGAwJHtoZXhDaGFyQ29kZX1gIDogaGV4Q2hhckNvZGU7XG4gICAgfVxuICAgIHJldHVybiBgMHgke2hleFN0cmluZ31gO1xufTtcbmV4cG9ydHMuYXNjaWlUb0hleCA9IGFzY2lpVG9IZXg7XG4vKipcbiAqIEBhbGlhcyBhc2NpaVRvSGV4XG4gKi9cbmV4cG9ydHMuZnJvbUFzY2lpID0gZXhwb3J0cy5hc2NpaVRvSGV4O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0gc3RyIC0gSGV4IHN0cmluZyB0byBiZSBjb252ZXJ0ZWQgdG8gYXNjaWlcbiAqIEByZXR1cm5zIC0gQXNjaWkgc3RyaW5nXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zb2xlLmxvZyh3ZWIzLnV0aWxzLmhleFRvQXNjaWkoJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NCcpKTtcbiAqID4gSGVsbG8gV29ybGRcbiAqIGBgYFxuICovXG5jb25zdCBoZXhUb0FzY2lpID0gKHN0cikgPT4ge1xuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ2FzY2lpJyk7XG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKCgwLCBleHBvcnRzLmhleFRvQnl0ZXMpKHN0cikpO1xufTtcbmV4cG9ydHMuaGV4VG9Bc2NpaSA9IGhleFRvQXNjaWk7XG4vKipcbiAqIEBhbGlhcyBoZXhUb0FzY2lpXG4gKi9cbmV4cG9ydHMudG9Bc2NpaSA9IGV4cG9ydHMuaGV4VG9Bc2NpaTtcbi8qKlxuICogQXV0byBjb252ZXJ0cyBhbnkgZ2l2ZW4gdmFsdWUgaW50byBpdCdzIGhleCByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGNvbnZlcnRlZCB0byBoZXhcbiAqIEBwYXJhbSByZXR1cm5UeXBlIC0gSWYgdHJ1ZSwgaXQgd2lsbCByZXR1cm4gdGhlIHR5cGUgb2YgdGhlIHZhbHVlXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zb2xlLmxvZyh3ZWIzLnV0aWxzLnRvSGV4KDEwKSk7XG4gKiA+IDB4YVxuICpcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMudG9IZXgoJzB4MTIzJywgdHJ1ZSkpO1xuICogPiBieXRlc1xuICpgYGBcbiAqL1xuY29uc3QgdG9IZXggPSAodmFsdWUsIHJldHVyblR5cGUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAoMCwgd2ViM192YWxpZGF0b3JfMS5pc0FkZHJlc3MpKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcmV0dXJuVHlwZSA/ICdhZGRyZXNzJyA6IGAweCR7dmFsdWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eMHgvaSwgJycpfWA7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgcmV0dXJuIHJldHVyblR5cGUgPyAnYm9vbCcgOiB2YWx1ZSA/ICcweDAxJyA6ICcweDAwJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gKHZhbHVlIDwgMCA/ICdpbnQyNTYnIDogJ3VpbnQyNTYnKSA6ICgwLCBleHBvcnRzLm51bWJlclRvSGV4KSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ2JpZ2ludCcgOiAoMCwgZXhwb3J0cy5udW1iZXJUb0hleCkodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ3N0cmluZycgOiAoMCwgZXhwb3J0cy51dGY4VG9IZXgpKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCctMHgnKSB8fCB2YWx1ZS5zdGFydHNXaXRoKCctMFgnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblR5cGUgPyAnaW50MjU2JyA6ICgwLCBleHBvcnRzLm51bWJlclRvSGV4KSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCB3ZWIzX3ZhbGlkYXRvcl8xLmlzSGV4U3RyaWN0KSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ2J5dGVzJyA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgd2ViM192YWxpZGF0b3JfMS5pc0hleCkodmFsdWUpICYmICEoMCwgd2ViM192YWxpZGF0b3JfMS5pc0ludCkodmFsdWUpICYmICEoMCwgd2ViM192YWxpZGF0b3JfMS5pc1VJbnQpKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblR5cGUgPyAnYnl0ZXMnIDogYDB4JHt2YWx1ZX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgd2ViM192YWxpZGF0b3JfMS5pc0hleCkodmFsdWUpICYmICEoMCwgd2ViM192YWxpZGF0b3JfMS5pc0ludCkodmFsdWUpICYmICgwLCB3ZWIzX3ZhbGlkYXRvcl8xLmlzVUludCkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVHlwZSA/ICd1aW50JyA6ICgwLCBleHBvcnRzLm51bWJlclRvSGV4KSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVHlwZSA/ICdzdHJpbmcnIDogKDAsIGV4cG9ydHMudXRmOFRvSGV4KSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IHdlYjNfZXJyb3JzXzEuSGV4UHJvY2Vzc2luZ0Vycm9yKHZhbHVlKTtcbn07XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG4vKipcbiAqIENvbnZlcnRzIGFueSBnaXZlbiB2YWx1ZSBpbnRvIGl0J3MgbnVtYmVyIHJlcHJlc2VudGF0aW9uLCBpZiBwb3NzaWJsZSwgZWxzZSBpbnRvIGl0J3MgYmlnaW50IHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIC0gUmV0dXJucyB0aGUgdmFsdWUgaW4gbnVtYmVyIG9yIGJpZ2ludCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc29sZS5sb2cod2ViMy51dGlscy50b051bWJlcigxKSk7XG4gKiA+IDFcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMudG9OdW1iZXIoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKTtcbiAqID4gOTAwNzE5OTI1NDc0MDk5MVxuICpcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMudG9OdW1iZXIoQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSkpO1xuICogPiA5MDA3MTk5MjU0NzQwOTkxXG4gKlxuICogY29uc29sZS5sb2cod2ViMy51dGlscy50b051bWJlcihCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpICsgQmlnSW50KDEpKSk7XG4gKiA+IDkwMDcxOTkyNTQ3NDA5OTJuXG4gKlxuICogYGBgXG4gKi9cbmNvbnN0IHRvTnVtYmVyID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPj0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICAgICAgICAgID8gTnVtYmVyKHZhbHVlKVxuICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgKDAsIHdlYjNfdmFsaWRhdG9yXzEuaXNIZXhTdHJpY3QpKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuaGV4VG9OdW1iZXIpKHZhbHVlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLnRvTnVtYmVyKShCaWdJbnQodmFsdWUpKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHRocm93IG5ldyB3ZWIzX2Vycm9yc18xLkludmFsaWROdW1iZXJFcnJvcih2YWx1ZSk7XG4gICAgfVxufTtcbmV4cG9ydHMudG9OdW1iZXIgPSB0b051bWJlcjtcbi8qKlxuICogQXV0byBjb252ZXJ0cyBhbnkgZ2l2ZW4gdmFsdWUgaW50byBpdCdzIGJpZ2ludCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyAtIFJldHVybnMgdGhlIHZhbHVlIGluIGJpZ2ludCByZXByZXNlbnRhdGlvblxuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMudG9CaWdJbnQoMSkpO1xuICogPiAxblxuICogYGBgXG4gKi9cbmNvbnN0IHRvQmlnSW50ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gaXNIZXggcGFzc2VzIGZvciBkZWMsIHRvb1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICgwLCB3ZWIzX3ZhbGlkYXRvcl8xLmlzSGV4KSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJy0nKSkge1xuICAgICAgICAgICAgcmV0dXJuIC1CaWdJbnQodmFsdWUuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IHdlYjNfZXJyb3JzXzEuSW52YWxpZE51bWJlckVycm9yKHZhbHVlKTtcbn07XG5leHBvcnRzLnRvQmlnSW50ID0gdG9CaWdJbnQ7XG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIG9mIHdlaSBhbmQgY29udmVydHMgaXQgdG8gYW55IG90aGVyIGV0aGVyIHVuaXQuXG4gKiBAcGFyYW0gbnVtYmVyIC0gVGhlIHZhbHVlIGluIHdlaVxuICogQHBhcmFtIHVuaXQgLSBUaGUgdW5pdCB0byBjb252ZXJ0IHRvXG4gKiBAcmV0dXJucyAtIFJldHVybnMgdGhlIGNvbnZlcnRlZCB2YWx1ZSBpbiB0aGUgZ2l2ZW4gdW5pdFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc29sZS5sb2cod2ViMy51dGlscy5mcm9tV2VpKFwiMVwiLCBcImV0aGVyXCIpKTtcbiAqID4gMC4wMDAwMDAwMDAwMDAwMDAwMDFcbiAqXG4gKiBjb25zb2xlLmxvZyh3ZWIzLnV0aWxzLmZyb21XZWkoXCIxXCIsIFwic2hhbm5vblwiKSk7XG4gKiA+IDAuMDAwMDAwMDAxXG4gKiBgYGBcbiAqL1xuY29uc3QgZnJvbVdlaSA9IChudW1iZXIsIHVuaXQpID0+IHtcbiAgICBjb25zdCBkZW5vbWluYXRpb24gPSBleHBvcnRzLmV0aFVuaXRNYXBbdW5pdF07XG4gICAgaWYgKCFkZW5vbWluYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IHdlYjNfZXJyb3JzXzEuSW52YWxpZFVuaXRFcnJvcih1bml0KTtcbiAgICB9XG4gICAgLy8gdmFsdWUgaW4gd2VpIHdvdWxkIGFsd2F5cyBiZSBpbnRlZ2VyXG4gICAgLy8gMTM0NTY3ODksIDEyMzRcbiAgICBjb25zdCB2YWx1ZSA9IFN0cmluZygoMCwgZXhwb3J0cy50b051bWJlcikobnVtYmVyKSk7XG4gICAgLy8gY291bnQgbnVtYmVyIG9mIHplcm9zIGluIGRlbm9taW5hdGlvblxuICAgIC8vIDEwMDAwMDAgLT4gNlxuICAgIGNvbnN0IG51bWJlck9mWmVyb3NJbkRlbm9taW5hdGlvbiA9IGRlbm9taW5hdGlvbi50b1N0cmluZygpLmxlbmd0aCAtIDE7XG4gICAgaWYgKG51bWJlck9mWmVyb3NJbkRlbm9taW5hdGlvbiA8PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLyBwYWQgdGhlIHZhbHVlIHdpdGggcmVxdWlyZWQgemVyb3NcbiAgICAvLyAxMzQ1Njc4OSAtPiAxMzQ1Njc4OSwgMTIzNCAtPiAwMDEyMzRcbiAgICBjb25zdCB6ZXJvUGFkZGVkVmFsdWUgPSB2YWx1ZS5wYWRTdGFydChudW1iZXJPZlplcm9zSW5EZW5vbWluYXRpb24sICcwJyk7XG4gICAgLy8gZ2V0IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdmFsdWUgYnkgY291bnRpbmcgbnVtYmVyIG9mIHplcm9zIGZyb20gc3RhcnRcbiAgICAvLyAxMzQ1Njc4OSAtPiAnMTMnXG4gICAgLy8gMDAxMjM0IC0+ICcnXG4gICAgY29uc3QgaW50ZWdlciA9IHplcm9QYWRkZWRWYWx1ZS5zbGljZSgwLCAtbnVtYmVyT2ZaZXJvc0luRGVub21pbmF0aW9uKTtcbiAgICAvLyBnZXQgdGhlIGZyYWN0aW9uIHBhcnQgb2YgdmFsdWUgYnkgY291bnRpbmcgbnVtYmVyIG9mIHplcm9zIGJhY2t3YXJkXG4gICAgLy8gMTM0NTY3ODkgLT4gJzQ1Njc4OSdcbiAgICAvLyAwMDEyMzQgLT4gJzAwMTIzNCdcbiAgICBjb25zdCBmcmFjdGlvbiA9IHplcm9QYWRkZWRWYWx1ZS5zbGljZSgtbnVtYmVyT2ZaZXJvc0luRGVub21pbmF0aW9uKS5yZXBsYWNlKC9cXC4/MCskLywgJycpO1xuICAgIGlmIChpbnRlZ2VyID09PSAnJykge1xuICAgICAgICByZXR1cm4gYDAuJHtmcmFjdGlvbn1gO1xuICAgIH1cbiAgICBpZiAoZnJhY3Rpb24gPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBpbnRlZ2VyO1xuICAgIH1cbiAgICByZXR1cm4gYCR7aW50ZWdlcn0uJHtmcmFjdGlvbn1gO1xufTtcbmV4cG9ydHMuZnJvbVdlaSA9IGZyb21XZWk7XG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIG9mIGEgdW5pdCBhbmQgY29udmVydHMgaXQgdG8gd2VpLlxuICpcbiAqIEBwYXJhbSBudW1iZXIgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gdW5pdCAtIHtAbGluayBFdGhlclVuaXRzfSBUaGUgdW5pdCBvZiB0aGUgbnVtYmVyIHBhc3NlZC5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgY29udmVydGVkIHRvIHdlaS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMudG9XZWkoXCIwLjAwMVwiLCBcImV0aGVyXCIpKTtcbiAqID4gMTAwMDAwMDAwMDAwMDAwMCAvLyh3ZWkpXG4gKiBgYGBcbiAqL1xuLy8gdG9kbyBpbiAxLnggdW5pdCBkZWZhdWx0cyB0byAnZXRoZXInXG5jb25zdCB0b1dlaSA9IChudW1iZXIsIHVuaXQpID0+IHtcbiAgICB3ZWIzX3ZhbGlkYXRvcl8xLnZhbGlkYXRvci52YWxpZGF0ZShbJ251bWJlciddLCBbbnVtYmVyXSk7XG4gICAgY29uc3QgZGVub21pbmF0aW9uID0gZXhwb3J0cy5ldGhVbml0TWFwW3VuaXRdO1xuICAgIGlmICghZGVub21pbmF0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyB3ZWIzX2Vycm9yc18xLkludmFsaWRVbml0RXJyb3IodW5pdCk7XG4gICAgfVxuICAgIC8vIGlmIHZhbHVlIGlzIGRlY2ltYWwgZS5nLiAyNC41NiBleHRyYWN0IGBpbnRlZ2VyYCBhbmQgYGZyYWN0aW9uYCBwYXJ0XG4gICAgLy8gdG8gYXZvaWQgYGZyYWN0aW9uYCB0byBiZSBudWxsIHVzZSBgY29uY2F0YCB3aXRoIGVtcHR5IHN0cmluZ1xuICAgIGNvbnN0IFtpbnRlZ2VyLCBmcmFjdGlvbl0gPSBTdHJpbmcodHlwZW9mIG51bWJlciA9PT0gJ3N0cmluZycgJiYgISgwLCB3ZWIzX3ZhbGlkYXRvcl8xLmlzSGV4U3RyaWN0KShudW1iZXIpID8gbnVtYmVyIDogKDAsIGV4cG9ydHMudG9OdW1iZXIpKG51bWJlcikpXG4gICAgICAgIC5zcGxpdCgnLicpXG4gICAgICAgIC5jb25jYXQoJycpO1xuICAgIC8vIGpvaW4gdGhlIHZhbHVlIHJlbW92aW5nIGAuYCBmcm9tXG4gICAgLy8gMjQuNTYgLT4gMjQ1NlxuICAgIGNvbnN0IHZhbHVlID0gQmlnSW50KGAke2ludGVnZXJ9JHtmcmFjdGlvbn1gKTtcbiAgICAvLyBtdWx0aXBseSB2YWx1ZSB3aXRoIGRlbm9taW5hdGlvblxuICAgIC8vIDI0NTYgKiAxMDAwMDAwIC0+IDI0NTYwMDAwMDBcbiAgICBjb25zdCB1cGRhdGVkVmFsdWUgPSB2YWx1ZSAqIGRlbm9taW5hdGlvbjtcbiAgICAvLyBjb3VudCBudW1iZXIgb2YgemVyb3MgaW4gZGVub21pbmF0aW9uXG4gICAgY29uc3QgbnVtYmVyT2ZaZXJvc0luRGVub21pbmF0aW9uID0gZGVub21pbmF0aW9uLnRvU3RyaW5nKCkubGVuZ3RoIC0gMTtcbiAgICAvLyBjaGVjayB3aGljaCBlaXRoZXIgYGZyYWN0aW9uYCBvciBgZGVub21pbmF0aW9uYCBoYXZlIGxvd2VyIG51bWJlciBvZiB6ZXJvc1xuICAgIGNvbnN0IGRlY2ltYWxzID0gTWF0aC5taW4oZnJhY3Rpb24ubGVuZ3RoLCBudW1iZXJPZlplcm9zSW5EZW5vbWluYXRpb24pO1xuICAgIGlmIChkZWNpbWFscyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdXBkYXRlZFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIGxlbmd0aCBlcXVhbCB0byByZXF1aXJlZCBkZWNpbWFsIHBvaW50c1xuICAgIC8vIElmIHN0cmluZyBpcyBsYXJnZXIgdGhhbiBkZWNpbWFsIHBvaW50cyByZXF1aXJlZCB0aGVuIHJlbW92ZSBsYXN0IHplcm9zXG4gICAgcmV0dXJuIHVwZGF0ZWRWYWx1ZS50b1N0cmluZygpLnBhZFN0YXJ0KGRlY2ltYWxzLCAnMCcpLnNsaWNlKDAsIC1kZWNpbWFscyk7XG59O1xuZXhwb3J0cy50b1dlaSA9IHRvV2VpO1xuLyoqXG4gKiBXaWxsIGNvbnZlcnQgYW4gdXBwZXIgb3IgbG93ZXJjYXNlIEV0aGVyZXVtIGFkZHJlc3MgdG8gYSBjaGVja3N1bSBhZGRyZXNzLlxuICogQHBhcmFtIGFkZHJlc3MgLSBBbiBhZGRyZXNzIHN0cmluZ1xuICogQHJldHVybnNcdFRoZSBjaGVja3N1bSBhZGRyZXNzXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIHdlYjMudXRpbHMudG9DaGVja3N1bUFkZHJlc3MoJzB4YzE5MTJmZWU0NWQ2MWM4N2NjNWVhNTlkYWUzMTE5MGZmZmZmMjMyZCcpO1xuICogPiBcIjB4YzE5MTJmRUU0NWQ2MUM4N0NjNUVBNTlEYUUzMTE5MEZGRkZmMjMyZFwiXG4gKiBgYGBcbiAqL1xuY29uc3QgdG9DaGVja3N1bUFkZHJlc3MgPSAoYWRkcmVzcykgPT4ge1xuICAgIGlmICghKDAsIHdlYjNfdmFsaWRhdG9yXzEuaXNBZGRyZXNzKShhZGRyZXNzLCBmYWxzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IHdlYjNfZXJyb3JzXzEuSW52YWxpZEFkZHJlc3NFcnJvcihhZGRyZXNzKTtcbiAgICB9XG4gICAgY29uc3QgbG93ZXJDYXNlQWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIC8vIGNhbGxpbmcgYFVpbnQ4QXJyYXkuZnJvbWAgYmVjYXVzZSBgbm9ibGUtaGFzaGVzYCBjaGVja3Mgd2l0aCBgaW5zdGFuY2VvZiBVaW50OEFycmF5YCB0aGF0IGZhaWxzIGluIHNvbWUgZWRnZSBjYXNlczpcbiAgICAvLyBcdGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtaGFzaGVzL2lzc3Vlcy8yNSNpc3N1ZWNvbW1lbnQtMTc1MDEwNjI4NFxuICAgIGNvbnN0IGhhc2ggPSB3ZWIzX3ZhbGlkYXRvcl8xLnV0aWxzLnVpbnQ4QXJyYXlUb0hleFN0cmluZygoMCwga2VjY2FrX2pzXzEua2VjY2FrMjU2KSh3ZWIzX3ZhbGlkYXRvcl8xLnV0aWxzLmVuc3VyZUlmVWludDhBcnJheSgoMCwgZXhwb3J0cy51dGY4VG9CeXRlcykobG93ZXJDYXNlQWRkcmVzcykpKSk7XG4gICAgaWYgKCgwLCB3ZWIzX3ZhbGlkYXRvcl8xLmlzTnVsbGlzaCkoaGFzaCkgfHxcbiAgICAgICAgaGFzaCA9PT0gJzB4YzVkMjQ2MDE4NmY3MjMzYzkyN2U3ZGIyZGNjNzAzYzBlNTAwYjY1M2NhODIyNzNiN2JmYWQ4MDQ1ZDg1YTQ3MCcpXG4gICAgICAgIHJldHVybiAnJzsgLy8gLy8gRUlQLTEwNTIgaWYgaGFzaCBpcyBlcXVhbCB0byBjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwLCBrZWNjYWsgd2FzIGdpdmVuIGVtcHR5IGRhdGFcbiAgICBsZXQgY2hlY2tzdW1BZGRyZXNzID0gJzB4JztcbiAgICBjb25zdCBhZGRyZXNzSGFzaCA9IGhhc2gucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvd2VyQ2FzZUFkZHJlc3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgLy8gSWYgaXRoIGNoYXJhY3RlciBpcyA4IHRvIGYgdGhlbiBtYWtlIGl0IHVwcGVyY2FzZVxuICAgICAgICBpZiAocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA+IDcpIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyArPSBsb3dlckNhc2VBZGRyZXNzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MgKz0gbG93ZXJDYXNlQWRkcmVzc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW1BZGRyZXNzO1xufTtcbmV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSB0b0NoZWNrc3VtQWRkcmVzcztcbmNvbnN0IHRvQm9vbCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICh2YWx1ZSA9PT0gMCB8fCB2YWx1ZSA9PT0gMSkpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyAmJiAodmFsdWUgPT09IEJpZ0ludCgwKSB8fCB2YWx1ZSA9PT0gQmlnSW50KDEpKSkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICEoMCwgd2ViM192YWxpZGF0b3JfMS5pc0hleFN0cmljdCkodmFsdWUpICYmXG4gICAgICAgICh2YWx1ZSA9PT0gJzEnIHx8IHZhbHVlID09PSAnMCcgfHwgdmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICd0cnVlJykpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCb29sZWFuKE51bWJlcih2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAoMCwgd2ViM192YWxpZGF0b3JfMS5pc0hleFN0cmljdCkodmFsdWUpICYmICh2YWx1ZSA9PT0gJzB4MScgfHwgdmFsdWUgPT09ICcweDAnKSkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbigoMCwgZXhwb3J0cy50b051bWJlcikodmFsdWUpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IHdlYjNfZXJyb3JzXzEuSW52YWxpZEJvb2xlYW5FcnJvcih2YWx1ZSk7XG59O1xuZXhwb3J0cy50b0Jvb2wgPSB0b0Jvb2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252ZXJ0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/converters.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/event_emitter.js":
/*!*****************************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/event_emitter.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/* eslint-disable max-classes-per-file */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventEmitter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst wrapFunction = (fn) => (params) => fn(params.detail);\n/**\n * This class copy the behavior of Node.js EventEmitter class.\n * It is used to provide the same interface for the browser environment.\n */\nclass EventEmitterAtBrowser extends EventTarget {\n    constructor() {\n        super(...arguments);\n        this._listeners = {};\n        this.maxListeners = Number.MAX_SAFE_INTEGER;\n    }\n    on(eventName, fn) {\n        this.addEventListener(eventName, fn);\n        return this;\n    }\n    once(eventName, fn) {\n        const onceCallback = (params) => __awaiter(this, void 0, void 0, function* () {\n            this.off(eventName, onceCallback);\n            yield fn(params);\n        });\n        return this.on(eventName, onceCallback);\n    }\n    off(eventName, fn) {\n        this.removeEventListener(eventName, fn);\n        return this;\n    }\n    emit(eventName, params) {\n        const event = new CustomEvent(eventName, { detail: params });\n        return super.dispatchEvent(event);\n    }\n    listenerCount(eventName) {\n        const eventListeners = this._listeners[eventName];\n        return eventListeners ? eventListeners.length : 0;\n    }\n    listeners(eventName) {\n        return this._listeners[eventName].map(value => value[0]) || [];\n    }\n    eventNames() {\n        return Object.keys(this._listeners);\n    }\n    removeAllListeners() {\n        Object.keys(this._listeners).forEach(event => {\n            this._listeners[event].forEach((listener) => {\n                super.removeEventListener(event, listener[1]);\n            });\n        });\n        this._listeners = {};\n        return this;\n    }\n    setMaxListeners(maxListeners) {\n        this.maxListeners = maxListeners;\n        return this;\n    }\n    getMaxListeners() {\n        return this.maxListeners;\n    }\n    addEventListener(eventName, fn) {\n        const wrappedFn = wrapFunction(fn);\n        super.addEventListener(eventName, wrappedFn);\n        if (!this._listeners[eventName]) {\n            this._listeners[eventName] = [];\n        }\n        this._listeners[eventName].push([fn, wrappedFn]);\n    }\n    removeEventListener(eventName, fn) {\n        const eventListeners = this._listeners[eventName];\n        if (eventListeners) {\n            const index = eventListeners.findIndex(item => item[0] === fn);\n            if (index !== -1) {\n                super.removeEventListener(eventName, eventListeners[index][1]);\n                eventListeners.splice(index, 1);\n            }\n        }\n    }\n}\n// eslint-disable-next-line import/no-mutable-exports\nlet EventEmitterType;\n// Check if the code is running in a Node.js environment\nif (typeof window === 'undefined') {\n    EventEmitterType = events_1.EventEmitter;\n}\nelse {\n    // Fallback for the browser environment\n    EventEmitterType = EventEmitterAtBrowser;\n}\nclass EventEmitter extends EventEmitterType {\n}\nexports.EventEmitter = EventEmitter;\n//# sourceMappingURL=event_emitter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9ldmVudF9lbWl0dGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXNzdWVyX2hvbGRlcl92ZXJpZmllci8uL3NyYy9wYWdlcy9hcGkvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL2NvbW1vbmpzL2V2ZW50X2VtaXR0ZXIuanM/MTc1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG5UaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG53ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbml0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxudGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbihhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbndlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbmJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG5NRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG5HTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG5hbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCB3cmFwRnVuY3Rpb24gPSAoZm4pID0+IChwYXJhbXMpID0+IGZuKHBhcmFtcy5kZXRhaWwpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIGNvcHkgdGhlIGJlaGF2aW9yIG9mIE5vZGUuanMgRXZlbnRFbWl0dGVyIGNsYXNzLlxuICogSXQgaXMgdXNlZCB0byBwcm92aWRlIHRoZSBzYW1lIGludGVyZmFjZSBmb3IgdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gKi9cbmNsYXNzIEV2ZW50RW1pdHRlckF0QnJvd3NlciBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgICAgIHRoaXMubWF4TGlzdGVuZXJzID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuICAgIG9uKGV2ZW50TmFtZSwgZm4pIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb25jZShldmVudE5hbWUsIGZuKSB7XG4gICAgICAgIGNvbnN0IG9uY2VDYWxsYmFjayA9IChwYXJhbXMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgb25jZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIHlpZWxkIGZuKHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5vbihldmVudE5hbWUsIG9uY2VDYWxsYmFjayk7XG4gICAgfVxuICAgIG9mZihldmVudE5hbWUsIGZuKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGVtaXQoZXZlbnROYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbDogcGFyYW1zIH0pO1xuICAgICAgICByZXR1cm4gc3VwZXIuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuICAgIGxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICAgIHJldHVybiBldmVudExpc3RlbmVycyA/IGV2ZW50TGlzdGVuZXJzLmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIGxpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVyc1tldmVudE5hbWVdLm1hcCh2YWx1ZSA9PiB2YWx1ZVswXSkgfHwgW107XG4gICAgfVxuICAgIGV2ZW50TmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9saXN0ZW5lcnMpO1xuICAgIH1cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xpc3RlbmVycykuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRdLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgc3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJbMV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldE1heExpc3RlbmVycyhtYXhMaXN0ZW5lcnMpIHtcbiAgICAgICAgdGhpcy5tYXhMaXN0ZW5lcnMgPSBtYXhMaXN0ZW5lcnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heExpc3RlbmVycztcbiAgICB9XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRGbiA9IHdyYXBGdW5jdGlvbihmbik7XG4gICAgICAgIHN1cGVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB3cmFwcGVkRm4pO1xuICAgICAgICBpZiAoIXRoaXMuX2xpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudE5hbWVdLnB1c2goW2ZuLCB3cmFwcGVkRm5dKTtcbiAgICB9XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICAgIGlmIChldmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBldmVudExpc3RlbmVycy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtWzBdID09PSBmbik7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXJzW2luZGV4XVsxXSk7XG4gICAgICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbXV0YWJsZS1leHBvcnRzXG5sZXQgRXZlbnRFbWl0dGVyVHlwZTtcbi8vIENoZWNrIGlmIHRoZSBjb2RlIGlzIHJ1bm5pbmcgaW4gYSBOb2RlLmpzIGVudmlyb25tZW50XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBFdmVudEVtaXR0ZXJUeXBlID0gZXZlbnRzXzEuRXZlbnRFbWl0dGVyO1xufVxuZWxzZSB7XG4gICAgLy8gRmFsbGJhY2sgZm9yIHRoZSBicm93c2VyIGVudmlyb25tZW50XG4gICAgRXZlbnRFbWl0dGVyVHlwZSA9IEV2ZW50RW1pdHRlckF0QnJvd3Nlcjtcbn1cbmNsYXNzIEV2ZW50RW1pdHRlciBleHRlbmRzIEV2ZW50RW1pdHRlclR5cGUge1xufVxuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudF9lbWl0dGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/event_emitter.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/formatter.js":
/*!*************************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/formatter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.format = exports.convert = exports.convertScalarValue = exports.isDataFormat = void 0;\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nconst web3_errors_1 = __webpack_require__(/*! web3-errors */ \"(api)/./src/pages/api/node_modules/web3-errors/lib/commonjs/index.js\");\nconst web3_types_1 = __webpack_require__(/*! web3-types */ \"(api)/./src/pages/api/node_modules/web3-types/lib/commonjs/index.js\");\nconst web3_validator_1 = __webpack_require__(/*! web3-validator */ \"(api)/./src/pages/api/node_modules/web3-validator/lib/commonjs/index.js\");\nconst converters_js_1 = __webpack_require__(/*! ./converters.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/converters.js\");\nconst objects_js_1 = __webpack_require__(/*! ./objects.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/objects.js\");\nconst string_manipulation_js_1 = __webpack_require__(/*! ./string_manipulation.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/string_manipulation.js\");\nconst uint8array_js_1 = __webpack_require__(/*! ./uint8array.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/uint8array.js\");\nconst { parseBaseType } = web3_validator_1.utils;\nconst isDataFormat = (dataFormat) => typeof dataFormat === 'object' &&\n    !(0, web3_validator_1.isNullish)(dataFormat) &&\n    'number' in dataFormat &&\n    'bytes' in dataFormat;\nexports.isDataFormat = isDataFormat;\n/**\n * Finds the schema that corresponds to a specific data path within a larger JSON schema.\n * It works by iterating over the dataPath array and traversing the JSON schema one step at a time until it reaches the end of the path.\n *\n * @param schema - represents a JSON schema, which is an object that describes the structure of JSON data\n * @param dataPath - represents an array of strings that specifies the path to the data within the JSON schema\n * @param oneOfPath - represents an optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns the JSON schema that matches the data path\n *\n */\nconst findSchemaByDataPath = (schema, dataPath, oneOfPath = []) => {\n    let result = Object.assign({}, schema);\n    let previousDataPath;\n    for (const dataPart of dataPath) {\n        if (result.oneOf && previousDataPath) {\n            const path = oneOfPath.find(function (element) {\n                return this === element[0];\n            }, previousDataPath !== null && previousDataPath !== void 0 ? previousDataPath : '');\n            if (path && path[0] === previousDataPath) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n                result = result.oneOf[path[1]];\n            }\n        }\n        if (!result.properties && !result.items) {\n            return undefined;\n        }\n        if (result.properties) {\n            result = result.properties[dataPart];\n        }\n        else if (result.items && result.items.properties) {\n            const node = result.items.properties;\n            if (!node) {\n                return undefined;\n            }\n            result = node[dataPart];\n        }\n        else if (result.items && (0, web3_validator_1.isObject)(result.items)) {\n            result = result.items;\n        }\n        else if (result.items && Array.isArray(result.items)) {\n            result = result.items[parseInt(dataPart, 10)];\n        }\n        if (result && dataPart)\n            previousDataPath = dataPart;\n    }\n    return result;\n};\n/**\n * Converts a value depending on the format\n * @param value - value to convert\n * @param ethType - The type of the value to be parsed\n * @param format - The format to be converted to\n * @returns - The value converted to the specified format\n */\nconst convertScalarValue = (value, ethType, format) => {\n    try {\n        const { baseType, baseTypeSize } = parseBaseType(ethType);\n        if (baseType === 'int' || baseType === 'uint') {\n            switch (format.number) {\n                case web3_types_1.FMT_NUMBER.NUMBER:\n                    return Number((0, converters_js_1.toBigInt)(value));\n                case web3_types_1.FMT_NUMBER.HEX:\n                    return (0, converters_js_1.numberToHex)((0, converters_js_1.toBigInt)(value));\n                case web3_types_1.FMT_NUMBER.STR:\n                    return (0, converters_js_1.toBigInt)(value).toString();\n                case web3_types_1.FMT_NUMBER.BIGINT:\n                    return (0, converters_js_1.toBigInt)(value);\n                default:\n                    throw new web3_errors_1.FormatterError(`Invalid format: ${String(format.number)}`);\n            }\n        }\n        if (baseType === 'bytes') {\n            let paddedValue;\n            if (baseTypeSize) {\n                if (typeof value === 'string')\n                    paddedValue = (0, string_manipulation_js_1.padLeft)(value, baseTypeSize * 2);\n                else if ((0, uint8array_js_1.isUint8Array)(value)) {\n                    paddedValue = (0, uint8array_js_1.uint8ArrayConcat)(new Uint8Array(baseTypeSize - value.length), value);\n                }\n            }\n            else {\n                paddedValue = value;\n            }\n            switch (format.bytes) {\n                case web3_types_1.FMT_BYTES.HEX:\n                    return (0, converters_js_1.bytesToHex)((0, converters_js_1.bytesToUint8Array)(paddedValue));\n                case web3_types_1.FMT_BYTES.UINT8ARRAY:\n                    return (0, converters_js_1.bytesToUint8Array)(paddedValue);\n                default:\n                    throw new web3_errors_1.FormatterError(`Invalid format: ${String(format.bytes)}`);\n            }\n        }\n    }\n    catch (error) {\n        // If someone didn't use `eth` keyword we can return original value\n        // as the scope of this code is formatting not validation\n        return value;\n    }\n    return value;\n};\nexports.convertScalarValue = convertScalarValue;\n/**\n * Converts the data to the specified format\n * @param data - data to convert\n * @param schema - The JSON schema that describes the structure of the data\n * @param dataPath - A string array that specifies the path to the data within the JSON schema\n * @param format  - The format to be converted to\n * @param oneOfPath - An optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns - The data converted to the specified format\n */\nconst convert = (data, schema, dataPath, format, oneOfPath = []) => {\n    var _a, _b;\n    // If it's a scalar value\n    if (!(0, web3_validator_1.isObject)(data) && !Array.isArray(data)) {\n        return (0, exports.convertScalarValue)(data, schema === null || schema === void 0 ? void 0 : schema.format, format);\n    }\n    const object = data;\n    for (const [key, value] of Object.entries(object)) {\n        dataPath.push(key);\n        const schemaProp = findSchemaByDataPath(schema, dataPath, oneOfPath);\n        // If value is a scaler value\n        if ((0, web3_validator_1.isNullish)(schemaProp)) {\n            delete object[key];\n            dataPath.pop();\n            continue;\n        }\n        // If value is an object, recurse into it\n        if ((0, web3_validator_1.isObject)(value)) {\n            (0, exports.convert)(value, schema, dataPath, format);\n            dataPath.pop();\n            continue;\n        }\n        // If value is an array\n        if (Array.isArray(value)) {\n            let _schemaProp = schemaProp;\n            // TODO This is a naive approach to solving the issue of\n            // a schema using oneOf. This chunk of code was intended to handle\n            // BlockSchema.transactions\n            // TODO BlockSchema.transactions are not being formatted\n            if ((schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.oneOf) !== undefined) {\n                // The following code is basically saying:\n                // if the schema specifies oneOf, then we are to loop\n                // over each possible schema and check if they type of the schema\n                // matches the type of value[0], and if so we use the oneOfSchemaProp\n                // as the schema for formatting\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n                schemaProp.oneOf.forEach((oneOfSchemaProp, index) => {\n                    var _a, _b;\n                    if (!Array.isArray(schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.items) &&\n                        ((typeof value[0] === 'object' &&\n                            ((_a = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _a === void 0 ? void 0 : _a.type) === 'object') ||\n                            (typeof value[0] === 'string' &&\n                                ((_b = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _b === void 0 ? void 0 : _b.type) !== 'object'))) {\n                        _schemaProp = oneOfSchemaProp;\n                        oneOfPath.push([key, index]);\n                    }\n                });\n            }\n            if ((0, web3_validator_1.isNullish)(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {\n                // Can not find schema for array item, delete that item\n                delete object[key];\n                dataPath.pop();\n                continue;\n            }\n            // If schema for array items is a single type\n            if ((0, web3_validator_1.isObject)(_schemaProp.items) && !(0, web3_validator_1.isNullish)(_schemaProp.items.format)) {\n                for (let i = 0; i < value.length; i += 1) {\n                    object[key][i] = (0, exports.convertScalarValue)(value[i], \n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                    (_a = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _a === void 0 ? void 0 : _a.format, format);\n                }\n                dataPath.pop();\n                continue;\n            }\n            // If schema for array items is an object\n            if (!Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) && ((_b = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _b === void 0 ? void 0 : _b.type) === 'object') {\n                for (const arrObject of value) {\n                    (0, exports.convert)(arrObject, schema, dataPath, format, oneOfPath);\n                }\n                dataPath.pop();\n                continue;\n            }\n            // If schema for array is a tuple\n            if (Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {\n                for (let i = 0; i < value.length; i += 1) {\n                    object[key][i] = (0, exports.convertScalarValue)(value[i], _schemaProp.items[i].format, format);\n                }\n                dataPath.pop();\n                continue;\n            }\n        }\n        object[key] = (0, exports.convertScalarValue)(value, schemaProp.format, format);\n        dataPath.pop();\n    }\n    return object;\n};\nexports.convert = convert;\nconst format = (schema, data, returnFormat) => {\n    let dataToParse;\n    if ((0, web3_validator_1.isObject)(data)) {\n        dataToParse = (0, objects_js_1.mergeDeep)({}, data);\n    }\n    else if (Array.isArray(data)) {\n        dataToParse = [...data];\n    }\n    else {\n        dataToParse = data;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const jsonSchema = (0, web3_validator_1.isObject)(schema) ? schema : web3_validator_1.utils.ethAbiToJsonSchema(schema);\n    if (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {\n        throw new web3_errors_1.FormatterError('Invalid json schema for formatting');\n    }\n    return (0, exports.convert)(dataToParse, jsonSchema, [], returnFormat);\n};\nexports.format = format;\n//# sourceMappingURL=formatter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9mb3JtYXR0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGVBQWUsR0FBRywwQkFBMEIsR0FBRyxvQkFBb0I7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHlGQUFhO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3pDLHlCQUF5QixtQkFBTyxDQUFDLCtGQUFnQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBaUI7QUFDakQscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0MsaUNBQWlDLG1CQUFPLENBQUMsbUhBQTBCO0FBQ25FLHdCQUF3QixtQkFBTyxDQUFDLGlHQUFpQjtBQUNqRCxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxzQkFBc0I7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxxQkFBcUI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXNzdWVyX2hvbGRlcl92ZXJpZmllci8uL3NyYy9wYWdlcy9hcGkvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL2NvbW1vbmpzL2Zvcm1hdHRlci5qcz82Zjg4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JtYXQgPSBleHBvcnRzLmNvbnZlcnQgPSBleHBvcnRzLmNvbnZlcnRTY2FsYXJWYWx1ZSA9IGV4cG9ydHMuaXNEYXRhRm9ybWF0ID0gdm9pZCAwO1xuLypcblRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbndlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG50aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxud2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbk1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbkdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG5Zb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbmFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5jb25zdCB3ZWIzX2Vycm9yc18xID0gcmVxdWlyZShcIndlYjMtZXJyb3JzXCIpO1xuY29uc3Qgd2ViM190eXBlc18xID0gcmVxdWlyZShcIndlYjMtdHlwZXNcIik7XG5jb25zdCB3ZWIzX3ZhbGlkYXRvcl8xID0gcmVxdWlyZShcIndlYjMtdmFsaWRhdG9yXCIpO1xuY29uc3QgY29udmVydGVyc19qc18xID0gcmVxdWlyZShcIi4vY29udmVydGVycy5qc1wiKTtcbmNvbnN0IG9iamVjdHNfanNfMSA9IHJlcXVpcmUoXCIuL29iamVjdHMuanNcIik7XG5jb25zdCBzdHJpbmdfbWFuaXB1bGF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdfbWFuaXB1bGF0aW9uLmpzXCIpO1xuY29uc3QgdWludDhhcnJheV9qc18xID0gcmVxdWlyZShcIi4vdWludDhhcnJheS5qc1wiKTtcbmNvbnN0IHsgcGFyc2VCYXNlVHlwZSB9ID0gd2ViM192YWxpZGF0b3JfMS51dGlscztcbmNvbnN0IGlzRGF0YUZvcm1hdCA9IChkYXRhRm9ybWF0KSA9PiB0eXBlb2YgZGF0YUZvcm1hdCA9PT0gJ29iamVjdCcgJiZcbiAgICAhKDAsIHdlYjNfdmFsaWRhdG9yXzEuaXNOdWxsaXNoKShkYXRhRm9ybWF0KSAmJlxuICAgICdudW1iZXInIGluIGRhdGFGb3JtYXQgJiZcbiAgICAnYnl0ZXMnIGluIGRhdGFGb3JtYXQ7XG5leHBvcnRzLmlzRGF0YUZvcm1hdCA9IGlzRGF0YUZvcm1hdDtcbi8qKlxuICogRmluZHMgdGhlIHNjaGVtYSB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgc3BlY2lmaWMgZGF0YSBwYXRoIHdpdGhpbiBhIGxhcmdlciBKU09OIHNjaGVtYS5cbiAqIEl0IHdvcmtzIGJ5IGl0ZXJhdGluZyBvdmVyIHRoZSBkYXRhUGF0aCBhcnJheSBhbmQgdHJhdmVyc2luZyB0aGUgSlNPTiBzY2hlbWEgb25lIHN0ZXAgYXQgYSB0aW1lIHVudGlsIGl0IHJlYWNoZXMgdGhlIGVuZCBvZiB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gc2NoZW1hIC0gcmVwcmVzZW50cyBhIEpTT04gc2NoZW1hLCB3aGljaCBpcyBhbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIHN0cnVjdHVyZSBvZiBKU09OIGRhdGFcbiAqIEBwYXJhbSBkYXRhUGF0aCAtIHJlcHJlc2VudHMgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHNwZWNpZmllcyB0aGUgcGF0aCB0byB0aGUgZGF0YSB3aXRoaW4gdGhlIEpTT04gc2NoZW1hXG4gKiBAcGFyYW0gb25lT2ZQYXRoIC0gcmVwcmVzZW50cyBhbiBvcHRpb25hbCBhcnJheSBvZiB0d28tZWxlbWVudCB0dXBsZXMgdGhhdCBzcGVjaWZpZXMgdGhlIFwib25lT2ZcIiBvcHRpb24gdG8gY2hvb3NlLCBpZiB0aGUgc2NoZW1hIGhhcyBvbmVPZiBhbmQgdGhlIGRhdGEgcGF0aCBjYW4gbWF0Y2ggbXVsdGlwbGUgc3Vic2NoZW1hc1xuICogQHJldHVybnMgdGhlIEpTT04gc2NoZW1hIHRoYXQgbWF0Y2hlcyB0aGUgZGF0YSBwYXRoXG4gKlxuICovXG5jb25zdCBmaW5kU2NoZW1hQnlEYXRhUGF0aCA9IChzY2hlbWEsIGRhdGFQYXRoLCBvbmVPZlBhdGggPSBbXSkgPT4ge1xuICAgIGxldCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBzY2hlbWEpO1xuICAgIGxldCBwcmV2aW91c0RhdGFQYXRoO1xuICAgIGZvciAoY29uc3QgZGF0YVBhcnQgb2YgZGF0YVBhdGgpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5vbmVPZiAmJiBwcmV2aW91c0RhdGFQYXRoKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gb25lT2ZQYXRoLmZpbmQoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcyA9PT0gZWxlbWVudFswXTtcbiAgICAgICAgICAgIH0sIHByZXZpb3VzRGF0YVBhdGggIT09IG51bGwgJiYgcHJldmlvdXNEYXRhUGF0aCAhPT0gdm9pZCAwID8gcHJldmlvdXNEYXRhUGF0aCA6ICcnKTtcbiAgICAgICAgICAgIGlmIChwYXRoICYmIHBhdGhbMF0gPT09IHByZXZpb3VzRGF0YVBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQub25lT2ZbcGF0aFsxXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQucHJvcGVydGllcyAmJiAhcmVzdWx0Lml0ZW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQucHJvcGVydGllcykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnByb3BlcnRpZXNbZGF0YVBhcnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdC5pdGVtcyAmJiByZXN1bHQuaXRlbXMucHJvcGVydGllcykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHJlc3VsdC5pdGVtcy5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IG5vZGVbZGF0YVBhcnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdC5pdGVtcyAmJiAoMCwgd2ViM192YWxpZGF0b3JfMS5pc09iamVjdCkocmVzdWx0Lml0ZW1zKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lml0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdC5pdGVtcyAmJiBBcnJheS5pc0FycmF5KHJlc3VsdC5pdGVtcykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5pdGVtc1twYXJzZUludChkYXRhUGFydCwgMTApXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICYmIGRhdGFQYXJ0KVxuICAgICAgICAgICAgcHJldmlvdXNEYXRhUGF0aCA9IGRhdGFQYXJ0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQ29udmVydHMgYSB2YWx1ZSBkZXBlbmRpbmcgb24gdGhlIGZvcm1hdFxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gY29udmVydFxuICogQHBhcmFtIGV0aFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gYmUgcGFyc2VkXG4gKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCB0byBiZSBjb252ZXJ0ZWQgdG9cbiAqIEByZXR1cm5zIC0gVGhlIHZhbHVlIGNvbnZlcnRlZCB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdFxuICovXG5jb25zdCBjb252ZXJ0U2NhbGFyVmFsdWUgPSAodmFsdWUsIGV0aFR5cGUsIGZvcm1hdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgYmFzZVR5cGUsIGJhc2VUeXBlU2l6ZSB9ID0gcGFyc2VCYXNlVHlwZShldGhUeXBlKTtcbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSAnaW50JyB8fCBiYXNlVHlwZSA9PT0gJ3VpbnQnKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdC5udW1iZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHdlYjNfdHlwZXNfMS5GTVRfTlVNQkVSLk5VTUJFUjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcigoMCwgY29udmVydGVyc19qc18xLnRvQmlnSW50KSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGNhc2Ugd2ViM190eXBlc18xLkZNVF9OVU1CRVIuSEVYOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNvbnZlcnRlcnNfanNfMS5udW1iZXJUb0hleCkoKDAsIGNvbnZlcnRlcnNfanNfMS50b0JpZ0ludCkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICBjYXNlIHdlYjNfdHlwZXNfMS5GTVRfTlVNQkVSLlNUUjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb252ZXJ0ZXJzX2pzXzEudG9CaWdJbnQpKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGNhc2Ugd2ViM190eXBlc18xLkZNVF9OVU1CRVIuQklHSU5UOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNvbnZlcnRlcnNfanNfMS50b0JpZ0ludCkodmFsdWUpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyB3ZWIzX2Vycm9yc18xLkZvcm1hdHRlckVycm9yKGBJbnZhbGlkIGZvcm1hdDogJHtTdHJpbmcoZm9ybWF0Lm51bWJlcil9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgICBsZXQgcGFkZGVkVmFsdWU7XG4gICAgICAgICAgICBpZiAoYmFzZVR5cGVTaXplKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHBhZGRlZFZhbHVlID0gKDAsIHN0cmluZ19tYW5pcHVsYXRpb25fanNfMS5wYWRMZWZ0KSh2YWx1ZSwgYmFzZVR5cGVTaXplICogMik7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKDAsIHVpbnQ4YXJyYXlfanNfMS5pc1VpbnQ4QXJyYXkpKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBwYWRkZWRWYWx1ZSA9ICgwLCB1aW50OGFycmF5X2pzXzEudWludDhBcnJheUNvbmNhdCkobmV3IFVpbnQ4QXJyYXkoYmFzZVR5cGVTaXplIC0gdmFsdWUubGVuZ3RoKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhZGRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdC5ieXRlcykge1xuICAgICAgICAgICAgICAgIGNhc2Ugd2ViM190eXBlc18xLkZNVF9CWVRFUy5IRVg6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29udmVydGVyc19qc18xLmJ5dGVzVG9IZXgpKCgwLCBjb252ZXJ0ZXJzX2pzXzEuYnl0ZXNUb1VpbnQ4QXJyYXkpKHBhZGRlZFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWIzX3R5cGVzXzEuRk1UX0JZVEVTLlVJTlQ4QVJSQVk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29udmVydGVyc19qc18xLmJ5dGVzVG9VaW50OEFycmF5KShwYWRkZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHdlYjNfZXJyb3JzXzEuRm9ybWF0dGVyRXJyb3IoYEludmFsaWQgZm9ybWF0OiAke1N0cmluZyhmb3JtYXQuYnl0ZXMpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiBzb21lb25lIGRpZG4ndCB1c2UgYGV0aGAga2V5d29yZCB3ZSBjYW4gcmV0dXJuIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgIC8vIGFzIHRoZSBzY29wZSBvZiB0aGlzIGNvZGUgaXMgZm9ybWF0dGluZyBub3QgdmFsaWRhdGlvblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnRzLmNvbnZlcnRTY2FsYXJWYWx1ZSA9IGNvbnZlcnRTY2FsYXJWYWx1ZTtcbi8qKlxuICogQ29udmVydHMgdGhlIGRhdGEgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXRcbiAqIEBwYXJhbSBkYXRhIC0gZGF0YSB0byBjb252ZXJ0XG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHRoYXQgZGVzY3JpYmVzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGRhdGFcbiAqIEBwYXJhbSBkYXRhUGF0aCAtIEEgc3RyaW5nIGFycmF5IHRoYXQgc3BlY2lmaWVzIHRoZSBwYXRoIHRvIHRoZSBkYXRhIHdpdGhpbiB0aGUgSlNPTiBzY2hlbWFcbiAqIEBwYXJhbSBmb3JtYXQgIC0gVGhlIGZvcm1hdCB0byBiZSBjb252ZXJ0ZWQgdG9cbiAqIEBwYXJhbSBvbmVPZlBhdGggLSBBbiBvcHRpb25hbCBhcnJheSBvZiB0d28tZWxlbWVudCB0dXBsZXMgdGhhdCBzcGVjaWZpZXMgdGhlIFwib25lT2ZcIiBvcHRpb24gdG8gY2hvb3NlLCBpZiB0aGUgc2NoZW1hIGhhcyBvbmVPZiBhbmQgdGhlIGRhdGEgcGF0aCBjYW4gbWF0Y2ggbXVsdGlwbGUgc3Vic2NoZW1hc1xuICogQHJldHVybnMgLSBUaGUgZGF0YSBjb252ZXJ0ZWQgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXRcbiAqL1xuY29uc3QgY29udmVydCA9IChkYXRhLCBzY2hlbWEsIGRhdGFQYXRoLCBmb3JtYXQsIG9uZU9mUGF0aCA9IFtdKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAvLyBJZiBpdCdzIGEgc2NhbGFyIHZhbHVlXG4gICAgaWYgKCEoMCwgd2ViM192YWxpZGF0b3JfMS5pc09iamVjdCkoZGF0YSkgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmNvbnZlcnRTY2FsYXJWYWx1ZSkoZGF0YSwgc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hLmZvcm1hdCwgZm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3Qgb2JqZWN0ID0gZGF0YTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmplY3QpKSB7XG4gICAgICAgIGRhdGFQYXRoLnB1c2goa2V5KTtcbiAgICAgICAgY29uc3Qgc2NoZW1hUHJvcCA9IGZpbmRTY2hlbWFCeURhdGFQYXRoKHNjaGVtYSwgZGF0YVBhdGgsIG9uZU9mUGF0aCk7XG4gICAgICAgIC8vIElmIHZhbHVlIGlzIGEgc2NhbGVyIHZhbHVlXG4gICAgICAgIGlmICgoMCwgd2ViM192YWxpZGF0b3JfMS5pc051bGxpc2gpKHNjaGVtYVByb3ApKSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqZWN0W2tleV07XG4gICAgICAgICAgICBkYXRhUGF0aC5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHZhbHVlIGlzIGFuIG9iamVjdCwgcmVjdXJzZSBpbnRvIGl0XG4gICAgICAgIGlmICgoMCwgd2ViM192YWxpZGF0b3JfMS5pc09iamVjdCkodmFsdWUpKSB7XG4gICAgICAgICAgICAoMCwgZXhwb3J0cy5jb252ZXJ0KSh2YWx1ZSwgc2NoZW1hLCBkYXRhUGF0aCwgZm9ybWF0KTtcbiAgICAgICAgICAgIGRhdGFQYXRoLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdmFsdWUgaXMgYW4gYXJyYXlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgX3NjaGVtYVByb3AgPSBzY2hlbWFQcm9wO1xuICAgICAgICAgICAgLy8gVE9ETyBUaGlzIGlzIGEgbmFpdmUgYXBwcm9hY2ggdG8gc29sdmluZyB0aGUgaXNzdWUgb2ZcbiAgICAgICAgICAgIC8vIGEgc2NoZW1hIHVzaW5nIG9uZU9mLiBUaGlzIGNodW5rIG9mIGNvZGUgd2FzIGludGVuZGVkIHRvIGhhbmRsZVxuICAgICAgICAgICAgLy8gQmxvY2tTY2hlbWEudHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAvLyBUT0RPIEJsb2NrU2NoZW1hLnRyYW5zYWN0aW9ucyBhcmUgbm90IGJlaW5nIGZvcm1hdHRlZFxuICAgICAgICAgICAgaWYgKChzY2hlbWFQcm9wID09PSBudWxsIHx8IHNjaGVtYVByb3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVtYVByb3Aub25lT2YpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgaXMgYmFzaWNhbGx5IHNheWluZzpcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc2NoZW1hIHNwZWNpZmllcyBvbmVPZiwgdGhlbiB3ZSBhcmUgdG8gbG9vcFxuICAgICAgICAgICAgICAgIC8vIG92ZXIgZWFjaCBwb3NzaWJsZSBzY2hlbWEgYW5kIGNoZWNrIGlmIHRoZXkgdHlwZSBvZiB0aGUgc2NoZW1hXG4gICAgICAgICAgICAgICAgLy8gbWF0Y2hlcyB0aGUgdHlwZSBvZiB2YWx1ZVswXSwgYW5kIGlmIHNvIHdlIHVzZSB0aGUgb25lT2ZTY2hlbWFQcm9wXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlIHNjaGVtYSBmb3IgZm9ybWF0dGluZ1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgICAgICAgICAgICAgIHNjaGVtYVByb3Aub25lT2YuZm9yRWFjaCgob25lT2ZTY2hlbWFQcm9wLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hUHJvcCA9PT0gbnVsbCB8fCBzY2hlbWFQcm9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWFQcm9wLml0ZW1zKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCh0eXBlb2YgdmFsdWVbMF0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYSA9IG9uZU9mU2NoZW1hUHJvcCA9PT0gbnVsbCB8fCBvbmVPZlNjaGVtYVByb3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uZU9mU2NoZW1hUHJvcC5pdGVtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSAnb2JqZWN0JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHZhbHVlWzBdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9iID0gb25lT2ZTY2hlbWFQcm9wID09PSBudWxsIHx8IG9uZU9mU2NoZW1hUHJvcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25lT2ZTY2hlbWFQcm9wLml0ZW1zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHlwZSkgIT09ICdvYmplY3QnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY2hlbWFQcm9wID0gb25lT2ZTY2hlbWFQcm9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lT2ZQYXRoLnB1c2goW2tleSwgaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCB3ZWIzX3ZhbGlkYXRvcl8xLmlzTnVsbGlzaCkoX3NjaGVtYVByb3AgPT09IG51bGwgfHwgX3NjaGVtYVByb3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zY2hlbWFQcm9wLml0ZW1zKSkge1xuICAgICAgICAgICAgICAgIC8vIENhbiBub3QgZmluZCBzY2hlbWEgZm9yIGFycmF5IGl0ZW0sIGRlbGV0ZSB0aGF0IGl0ZW1cbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgZGF0YVBhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBzY2hlbWEgZm9yIGFycmF5IGl0ZW1zIGlzIGEgc2luZ2xlIHR5cGVcbiAgICAgICAgICAgIGlmICgoMCwgd2ViM192YWxpZGF0b3JfMS5pc09iamVjdCkoX3NjaGVtYVByb3AuaXRlbXMpICYmICEoMCwgd2ViM192YWxpZGF0b3JfMS5pc051bGxpc2gpKF9zY2hlbWFQcm9wLml0ZW1zLmZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldW2ldID0gKDAsIGV4cG9ydHMuY29udmVydFNjYWxhclZhbHVlKSh2YWx1ZVtpXSwgXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IF9zY2hlbWFQcm9wID09PSBudWxsIHx8IF9zY2hlbWFQcm9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc2NoZW1hUHJvcC5pdGVtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcm1hdCwgZm9ybWF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YVBhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBzY2hlbWEgZm9yIGFycmF5IGl0ZW1zIGlzIGFuIG9iamVjdFxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KF9zY2hlbWFQcm9wID09PSBudWxsIHx8IF9zY2hlbWFQcm9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc2NoZW1hUHJvcC5pdGVtcykgJiYgKChfYiA9IF9zY2hlbWFQcm9wID09PSBudWxsIHx8IF9zY2hlbWFQcm9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc2NoZW1hUHJvcC5pdGVtcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnR5cGUpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXJyT2JqZWN0IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBleHBvcnRzLmNvbnZlcnQpKGFyck9iamVjdCwgc2NoZW1hLCBkYXRhUGF0aCwgZm9ybWF0LCBvbmVPZlBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhUGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHNjaGVtYSBmb3IgYXJyYXkgaXMgYSB0dXBsZVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX3NjaGVtYVByb3AgPT09IG51bGwgfHwgX3NjaGVtYVByb3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zY2hlbWFQcm9wLml0ZW1zKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2tleV1baV0gPSAoMCwgZXhwb3J0cy5jb252ZXJ0U2NhbGFyVmFsdWUpKHZhbHVlW2ldLCBfc2NoZW1hUHJvcC5pdGVtc1tpXS5mb3JtYXQsIGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFQYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9iamVjdFtrZXldID0gKDAsIGV4cG9ydHMuY29udmVydFNjYWxhclZhbHVlKSh2YWx1ZSwgc2NoZW1hUHJvcC5mb3JtYXQsIGZvcm1hdCk7XG4gICAgICAgIGRhdGFQYXRoLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcbmV4cG9ydHMuY29udmVydCA9IGNvbnZlcnQ7XG5jb25zdCBmb3JtYXQgPSAoc2NoZW1hLCBkYXRhLCByZXR1cm5Gb3JtYXQpID0+IHtcbiAgICBsZXQgZGF0YVRvUGFyc2U7XG4gICAgaWYgKCgwLCB3ZWIzX3ZhbGlkYXRvcl8xLmlzT2JqZWN0KShkYXRhKSkge1xuICAgICAgICBkYXRhVG9QYXJzZSA9ICgwLCBvYmplY3RzX2pzXzEubWVyZ2VEZWVwKSh7fSwgZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgZGF0YVRvUGFyc2UgPSBbLi4uZGF0YV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXRhVG9QYXJzZSA9IGRhdGE7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICBjb25zdCBqc29uU2NoZW1hID0gKDAsIHdlYjNfdmFsaWRhdG9yXzEuaXNPYmplY3QpKHNjaGVtYSkgPyBzY2hlbWEgOiB3ZWIzX3ZhbGlkYXRvcl8xLnV0aWxzLmV0aEFiaVRvSnNvblNjaGVtYShzY2hlbWEpO1xuICAgIGlmICghanNvblNjaGVtYS5wcm9wZXJ0aWVzICYmICFqc29uU2NoZW1hLml0ZW1zICYmICFqc29uU2NoZW1hLmZvcm1hdCkge1xuICAgICAgICB0aHJvdyBuZXcgd2ViM19lcnJvcnNfMS5Gb3JtYXR0ZXJFcnJvcignSW52YWxpZCBqc29uIHNjaGVtYSBmb3IgZm9ybWF0dGluZycpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuY29udmVydCkoZGF0YVRvUGFyc2UsIGpzb25TY2hlbWEsIFtdLCByZXR1cm5Gb3JtYXQpO1xufTtcbmV4cG9ydHMuZm9ybWF0ID0gZm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0dGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/formatter.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/hash.js":
/*!********************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/hash.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getStorageSlotNumForLongString = exports.soliditySha3Raw = exports.soliditySha3 = exports.encodePacked = exports.processSolidityEncodePackedArgs = exports.keccak256 = exports.keccak256Wrapper = exports.sha3Raw = exports.sha3 = void 0;\n/**\n * This package provides utility functions for Ethereum dapps and other web3.js packages.\n *\n * For using Utils functions, first install Web3 package using `npm i web3` or `yarn add web3`.\n * After that, Web3 Utils functions will be available as mentioned below.\n * ```ts\n * import { Web3 } from 'web3';\n * const web3 = new Web3();\n *\n * const value = web3.utils.fromWei(\"1\", \"ether\")\n *\n * ```\n *\n * For using individual package install `web3-utils` package using `npm i web3-utils` or `yarn add web3-utils` and only import required functions.\n * This is more efficient approach for building lightweight applications.\n * ```ts\n * import { fromWei, soliditySha3Raw } from 'web3-utils';\n *\n * console.log(fromWei(\"1\", \"ether\"));\n * console.log(soliditySha3Raw({ type: \"string\", value: \"helloworld\" }))\n *\n * ```\n * @module Utils\n */\nconst keccak_js_1 = __webpack_require__(/*! ethereum-cryptography/keccak.js */ \"(api)/./src/pages/api/node_modules/ethereum-cryptography/keccak.js\");\nconst utils_js_1 = __webpack_require__(/*! ethereum-cryptography/utils.js */ \"(api)/./src/pages/api/node_modules/ethereum-cryptography/utils.js\");\nconst web3_errors_1 = __webpack_require__(/*! web3-errors */ \"(api)/./src/pages/api/node_modules/web3-errors/lib/commonjs/index.js\");\nconst web3_validator_1 = __webpack_require__(/*! web3-validator */ \"(api)/./src/pages/api/node_modules/web3-validator/lib/commonjs/index.js\");\nconst converters_js_1 = __webpack_require__(/*! ./converters.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/converters.js\");\nconst string_manipulation_js_1 = __webpack_require__(/*! ./string_manipulation.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/string_manipulation.js\");\nconst SHA3_EMPTY_BYTES = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\n * computes the Keccak-256 hash of the input and returns a hexstring\n * @param data - the input to hash\n * @returns - the Keccak-256 hash of the input\n *\n * @example\n * ```ts\n * console.log(web3.utils.sha3('web3.js'));\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\n *\n * console.log(web3.utils.sha3(''));\n * > undefined\n * ```\n */\nconst sha3 = (data) => {\n    let updatedData;\n    if (typeof data === 'string') {\n        if (data.startsWith('0x') && (0, web3_validator_1.isHexStrict)(data)) {\n            updatedData = (0, converters_js_1.hexToBytes)(data);\n        }\n        else {\n            updatedData = (0, utils_js_1.utf8ToBytes)(data);\n        }\n    }\n    else {\n        updatedData = data;\n    }\n    const hash = (0, converters_js_1.bytesToHex)((0, keccak_js_1.keccak256)(web3_validator_1.utils.ensureIfUint8Array(updatedData)));\n    // EIP-1052 if hash is equal to c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, keccak was given empty data\n    return hash === SHA3_EMPTY_BYTES ? undefined : hash;\n};\nexports.sha3 = sha3;\n/**\n * Will calculate the sha3 of the input but does return the hash value instead of null if for example a empty string is passed.\n * @param data - the input to hash\n * @returns - the Keccak-256 hash of the input\n *\n * @example\n * ```ts\n * conosle.log(web3.utils.sha3Raw('web3.js'));\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\n *\n * console.log(web3.utils.sha3Raw(''));\n * > 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n * ```\n */\nconst sha3Raw = (data) => {\n    const hash = (0, exports.sha3)(data);\n    if ((0, web3_validator_1.isNullish)(hash)) {\n        return SHA3_EMPTY_BYTES;\n    }\n    return hash;\n};\nexports.sha3Raw = sha3Raw;\n/**\n * A wrapper for ethereum-cryptography/keccak256 to allow hashing a `string` and a `bigint` in addition to `UInt8Array`\n * @param data - the input to hash\n * @returns - the Keccak-256 hash of the input\n *\n * @example\n * ```ts\n * console.log(web3.utils.keccak256Wrapper('web3.js'));\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\n *\n * console.log(web3.utils.keccak256Wrapper(1));\n * > 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6\n *\n * console.log(web3.utils.keccak256Wrapper(0xaf12fd));\n * > 0x358640fd4719fa923525d74ab5ae80a594301aba5543e3492b052bf4598b794c\n * ```\n */\nconst keccak256Wrapper = (data) => {\n    let processedData;\n    if (typeof data === 'bigint' || typeof data === 'number') {\n        processedData = (0, utils_js_1.utf8ToBytes)(data.toString());\n    }\n    else if (Array.isArray(data)) {\n        processedData = new Uint8Array(data);\n    }\n    else if (typeof data === 'string' && !(0, web3_validator_1.isHexStrict)(data)) {\n        processedData = (0, utils_js_1.utf8ToBytes)(data);\n    }\n    else {\n        processedData = (0, converters_js_1.bytesToUint8Array)(data);\n    }\n    return (0, converters_js_1.bytesToHex)((0, keccak_js_1.keccak256)(web3_validator_1.utils.ensureIfUint8Array(processedData)));\n};\nexports.keccak256Wrapper = keccak256Wrapper;\nexports.keccak256 = exports.keccak256Wrapper;\n/**\n * returns type and value\n * @param arg - the input to return the type and value\n * @returns - the type and value of the input\n */\nconst getType = (arg) => {\n    if (Array.isArray(arg)) {\n        throw new Error('Autodetection of array types is not supported.');\n    }\n    let type;\n    let value;\n    // if type is given\n    if (typeof arg === 'object' &&\n        ('t' in arg || 'type' in arg) &&\n        ('v' in arg || 'value' in arg)) {\n        type = 't' in arg ? arg.t : arg.type;\n        value = 'v' in arg ? arg.v : arg.value;\n        type = type.toLowerCase() === 'bigint' ? 'int' : type;\n    }\n    else if (typeof arg === 'bigint') {\n        return ['int', arg];\n    }\n    // otherwise try to guess the type\n    else {\n        type = (0, converters_js_1.toHex)(arg, true);\n        value = (0, converters_js_1.toHex)(arg);\n        if (!type.startsWith('int') && !type.startsWith('uint')) {\n            type = 'bytes';\n        }\n    }\n    if ((type.startsWith('int') || type.startsWith('uint')) &&\n        typeof value === 'string' &&\n        !/^(-)?0x/i.test(value)) {\n        value = (0, converters_js_1.toBigInt)(value);\n    }\n    return [type, value];\n};\n/**\n * returns the type with size if uint or int\n * @param name - the input to return the type with size\n * @returns - the type with size of the input\n */\nconst elementaryName = (name) => {\n    if (name.startsWith('int[')) {\n        return `int256${name.slice(3)}`;\n    }\n    if (name === 'int') {\n        return 'int256';\n    }\n    if (name.startsWith('uint[')) {\n        return `uint256'${name.slice(4)}`;\n    }\n    if (name === 'uint') {\n        return 'uint256';\n    }\n    return name;\n};\n/**\n * returns the size of the value of type 'byte'\n */\nconst parseTypeN = (value, typeLength) => {\n    const typesize = /^(\\d+).*$/.exec(value.slice(typeLength));\n    return typesize ? parseInt(typesize[1], 10) : 0;\n};\n/**\n * returns the bit length of the value\n * @param value - the input to return the bit length\n * @returns - the bit length of the input\n */\nconst bitLength = (value) => {\n    const updatedVal = value.toString(2);\n    return updatedVal.length;\n};\n/**\n * Pads the value based on size and type\n * returns a string of the padded value\n * @param type - the input to pad\n * @returns = the padded value\n */\nconst solidityPack = (type, val) => {\n    const value = val.toString();\n    if (type === 'string') {\n        if (typeof val === 'string')\n            return (0, converters_js_1.utf8ToHex)(val);\n        throw new web3_errors_1.InvalidStringError(val);\n    }\n    if (type === 'bool' || type === 'boolean') {\n        if (typeof val === 'boolean')\n            return val ? '01' : '00';\n        throw new web3_errors_1.InvalidBooleanError(val);\n    }\n    if (type === 'address') {\n        if (!(0, web3_validator_1.isAddress)(value)) {\n            throw new web3_errors_1.InvalidAddressError(value);\n        }\n        return value;\n    }\n    const name = elementaryName(type);\n    if (type.startsWith('uint')) {\n        const size = parseTypeN(name, 'uint'.length);\n        if (size % 8 || size < 8 || size > 256) {\n            throw new web3_errors_1.InvalidSizeError(value);\n        }\n        const num = (0, converters_js_1.toNumber)(value);\n        if (bitLength(num) > size) {\n            throw new web3_errors_1.InvalidLargeValueError(value);\n        }\n        if (num < BigInt(0)) {\n            throw new web3_errors_1.InvalidUnsignedIntegerError(value);\n        }\n        return size ? (0, string_manipulation_js_1.leftPad)(num.toString(16), (size / 8) * 2) : num.toString(16);\n    }\n    if (type.startsWith('int')) {\n        const size = parseTypeN(name, 'int'.length);\n        if (size % 8 || size < 8 || size > 256) {\n            throw new web3_errors_1.InvalidSizeError(type);\n        }\n        const num = (0, converters_js_1.toNumber)(value);\n        if (bitLength(num) > size) {\n            throw new web3_errors_1.InvalidLargeValueError(value);\n        }\n        if (num < BigInt(0)) {\n            return (0, string_manipulation_js_1.toTwosComplement)(num.toString(), (size / 8) * 2);\n        }\n        return size ? (0, string_manipulation_js_1.leftPad)(num.toString(16), size / 4) : num.toString(16);\n    }\n    if (name === 'bytes') {\n        if (value.replace(/^0x/i, '').length % 2 !== 0) {\n            throw new web3_errors_1.InvalidBytesError(value);\n        }\n        return value;\n    }\n    if (type.startsWith('bytes')) {\n        if (value.replace(/^0x/i, '').length % 2 !== 0) {\n            throw new web3_errors_1.InvalidBytesError(value);\n        }\n        const size = parseTypeN(type, 'bytes'.length);\n        if (!size || size < 1 || size > 64 || size < value.replace(/^0x/i, '').length / 2) {\n            throw new web3_errors_1.InvalidBytesError(value);\n        }\n        return (0, string_manipulation_js_1.rightPad)(value, size * 2);\n    }\n    return '';\n};\n/**\n * returns a string of the tightly packed value given based on the type\n * @param arg - the input to return the tightly packed value\n * @returns - the tightly packed value\n */\nconst processSolidityEncodePackedArgs = (arg) => {\n    const [type, val] = getType(arg);\n    // array case\n    if (Array.isArray(val)) {\n        // go through each element of the array and use map function to create new hexarg list\n        const hexArg = val.map((v) => solidityPack(type, v).replace('0x', ''));\n        return hexArg.join('');\n    }\n    const hexArg = solidityPack(type, val);\n    return hexArg.replace('0x', '');\n};\nexports.processSolidityEncodePackedArgs = processSolidityEncodePackedArgs;\n/**\n * Encode packed arguments to a hexstring\n */\nconst encodePacked = (...values) => {\n    const hexArgs = values.map(exports.processSolidityEncodePackedArgs);\n    return `0x${hexArgs.join('').toLowerCase()}`;\n};\nexports.encodePacked = encodePacked;\n/**\n * Will tightly pack values given in the same way solidity would then hash.\n * returns a hash string, or null if input is empty\n * @param values - the input to return the tightly packed values\n * @returns - the keccack246 of the tightly packed values\n *\n * @example\n * ```ts\n * console.log(web3.utils.soliditySha3({ type: \"string\", value: \"31323334\" }));\n * > 0xf15f8da2ad27e486d632dc37d24912f634398918d6f9913a0a0ff84e388be62b\n * ```\n */\nconst soliditySha3 = (...values) => (0, exports.sha3)((0, exports.encodePacked)(...values));\nexports.soliditySha3 = soliditySha3;\n/**\n * Will tightly pack values given in the same way solidity would then hash.\n * returns a hash string, if input is empty will return `0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`\n * @param values - the input to return the tightly packed values\n * @returns - the keccack246 of the tightly packed values\n *\n * @example\n * ```ts\n * console.log(web3.utils.soliditySha3Raw({ type: \"string\", value: \"helloworld\" }))\n * > 0xfa26db7ca85ead399216e7c6316bc50ed24393c3122b582735e7f3b0f91b93f0\n * ```\n */\nconst soliditySha3Raw = (...values) => (0, exports.sha3Raw)((0, exports.encodePacked)(...values));\nexports.soliditySha3Raw = soliditySha3Raw;\n/**\n * Get slot number for storage long string in contract. Basically for getStorage method\n * returns slotNumber where will data placed\n * @param mainSlotNumber - the slot number where will be stored hash of long string\n * @returns - the slot number where will be stored long string\n */\nconst getStorageSlotNumForLongString = (mainSlotNumber) => (0, exports.sha3)(`0x${(typeof mainSlotNumber === 'number'\n    ? mainSlotNumber.toString()\n    : mainSlotNumber).padStart(64, '0')}`);\nexports.getStorageSlotNumForLongString = getStorageSlotNumForLongString;\n//# sourceMappingURL=hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9oYXNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0MsR0FBRyx1QkFBdUIsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyx1Q0FBdUMsR0FBRyxpQkFBaUIsR0FBRyx3QkFBd0IsR0FBRyxlQUFlLEdBQUcsWUFBWTtBQUN4TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBLGlDQUFpQyxxQ0FBcUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQywyR0FBaUM7QUFDN0QsbUJBQW1CLG1CQUFPLENBQUMseUdBQWdDO0FBQzNELHNCQUFzQixtQkFBTyxDQUFDLHlGQUFhO0FBQzNDLHlCQUF5QixtQkFBTyxDQUFDLCtGQUFnQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBaUI7QUFDakQsaUNBQWlDLG1CQUFPLENBQUMsbUhBQTBCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1DQUFtQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHFDQUFxQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQSx3Q0FBd0M7QUFDeEMsc0NBQXNDO0FBQ3RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXNzdWVyX2hvbGRlcl92ZXJpZmllci8uL3NyYy9wYWdlcy9hcGkvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL2NvbW1vbmpzL2hhc2guanM/YjcxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG5UaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG53ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbml0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxudGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbihhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbndlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbmJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG5NRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG5HTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG5hbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTdG9yYWdlU2xvdE51bUZvckxvbmdTdHJpbmcgPSBleHBvcnRzLnNvbGlkaXR5U2hhM1JhdyA9IGV4cG9ydHMuc29saWRpdHlTaGEzID0gZXhwb3J0cy5lbmNvZGVQYWNrZWQgPSBleHBvcnRzLnByb2Nlc3NTb2xpZGl0eUVuY29kZVBhY2tlZEFyZ3MgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMua2VjY2FrMjU2V3JhcHBlciA9IGV4cG9ydHMuc2hhM1JhdyA9IGV4cG9ydHMuc2hhMyA9IHZvaWQgMDtcbi8qKlxuICogVGhpcyBwYWNrYWdlIHByb3ZpZGVzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBFdGhlcmV1bSBkYXBwcyBhbmQgb3RoZXIgd2ViMy5qcyBwYWNrYWdlcy5cbiAqXG4gKiBGb3IgdXNpbmcgVXRpbHMgZnVuY3Rpb25zLCBmaXJzdCBpbnN0YWxsIFdlYjMgcGFja2FnZSB1c2luZyBgbnBtIGkgd2ViM2Agb3IgYHlhcm4gYWRkIHdlYjNgLlxuICogQWZ0ZXIgdGhhdCwgV2ViMyBVdGlscyBmdW5jdGlvbnMgd2lsbCBiZSBhdmFpbGFibGUgYXMgbWVudGlvbmVkIGJlbG93LlxuICogYGBgdHNcbiAqIGltcG9ydCB7IFdlYjMgfSBmcm9tICd3ZWIzJztcbiAqIGNvbnN0IHdlYjMgPSBuZXcgV2ViMygpO1xuICpcbiAqIGNvbnN0IHZhbHVlID0gd2ViMy51dGlscy5mcm9tV2VpKFwiMVwiLCBcImV0aGVyXCIpXG4gKlxuICogYGBgXG4gKlxuICogRm9yIHVzaW5nIGluZGl2aWR1YWwgcGFja2FnZSBpbnN0YWxsIGB3ZWIzLXV0aWxzYCBwYWNrYWdlIHVzaW5nIGBucG0gaSB3ZWIzLXV0aWxzYCBvciBgeWFybiBhZGQgd2ViMy11dGlsc2AgYW5kIG9ubHkgaW1wb3J0IHJlcXVpcmVkIGZ1bmN0aW9ucy5cbiAqIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgYXBwcm9hY2ggZm9yIGJ1aWxkaW5nIGxpZ2h0d2VpZ2h0IGFwcGxpY2F0aW9ucy5cbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tV2VpLCBzb2xpZGl0eVNoYTNSYXcgfSBmcm9tICd3ZWIzLXV0aWxzJztcbiAqXG4gKiBjb25zb2xlLmxvZyhmcm9tV2VpKFwiMVwiLCBcImV0aGVyXCIpKTtcbiAqIGNvbnNvbGUubG9nKHNvbGlkaXR5U2hhM1Jhdyh7IHR5cGU6IFwic3RyaW5nXCIsIHZhbHVlOiBcImhlbGxvd29ybGRcIiB9KSlcbiAqXG4gKiBgYGBcbiAqIEBtb2R1bGUgVXRpbHNcbiAqL1xuY29uc3Qga2VjY2FrX2pzXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3V0aWxzLmpzXCIpO1xuY29uc3Qgd2ViM19lcnJvcnNfMSA9IHJlcXVpcmUoXCJ3ZWIzLWVycm9yc1wiKTtcbmNvbnN0IHdlYjNfdmFsaWRhdG9yXzEgPSByZXF1aXJlKFwid2ViMy12YWxpZGF0b3JcIik7XG5jb25zdCBjb252ZXJ0ZXJzX2pzXzEgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzLmpzXCIpO1xuY29uc3Qgc3RyaW5nX21hbmlwdWxhdGlvbl9qc18xID0gcmVxdWlyZShcIi4vc3RyaW5nX21hbmlwdWxhdGlvbi5qc1wiKTtcbmNvbnN0IFNIQTNfRU1QVFlfQllURVMgPSAnMHhjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbi8qKlxuICogY29tcHV0ZXMgdGhlIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgaW5wdXQgYW5kIHJldHVybnMgYSBoZXhzdHJpbmdcbiAqIEBwYXJhbSBkYXRhIC0gdGhlIGlucHV0IHRvIGhhc2hcbiAqIEByZXR1cm5zIC0gdGhlIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgaW5wdXRcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMuc2hhMygnd2ViMy5qcycpKTtcbiAqID4gMHg2MzY2N2VmYjE5NjEwMzljOWJiMGQ2ZWE3YTVhYmRkMjIzYTNhY2E3ZGFhNTA0NGFkODk0MjI2ZTFmODM5MTlhXG4gKlxuICogY29uc29sZS5sb2cod2ViMy51dGlscy5zaGEzKCcnKSk7XG4gKiA+IHVuZGVmaW5lZFxuICogYGBgXG4gKi9cbmNvbnN0IHNoYTMgPSAoZGF0YSkgPT4ge1xuICAgIGxldCB1cGRhdGVkRGF0YTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkYXRhLnN0YXJ0c1dpdGgoJzB4JykgJiYgKDAsIHdlYjNfdmFsaWRhdG9yXzEuaXNIZXhTdHJpY3QpKGRhdGEpKSB7XG4gICAgICAgICAgICB1cGRhdGVkRGF0YSA9ICgwLCBjb252ZXJ0ZXJzX2pzXzEuaGV4VG9CeXRlcykoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVkRGF0YSA9ICgwLCB1dGlsc19qc18xLnV0ZjhUb0J5dGVzKShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXBkYXRlZERhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBoYXNoID0gKDAsIGNvbnZlcnRlcnNfanNfMS5ieXRlc1RvSGV4KSgoMCwga2VjY2FrX2pzXzEua2VjY2FrMjU2KSh3ZWIzX3ZhbGlkYXRvcl8xLnV0aWxzLmVuc3VyZUlmVWludDhBcnJheSh1cGRhdGVkRGF0YSkpKTtcbiAgICAvLyBFSVAtMTA1MiBpZiBoYXNoIGlzIGVxdWFsIHRvIGM1ZDI0NjAxODZmNzIzM2M5MjdlN2RiMmRjYzcwM2MwZTUwMGI2NTNjYTgyMjczYjdiZmFkODA0NWQ4NWE0NzAsIGtlY2NhayB3YXMgZ2l2ZW4gZW1wdHkgZGF0YVxuICAgIHJldHVybiBoYXNoID09PSBTSEEzX0VNUFRZX0JZVEVTID8gdW5kZWZpbmVkIDogaGFzaDtcbn07XG5leHBvcnRzLnNoYTMgPSBzaGEzO1xuLyoqXG4gKiBXaWxsIGNhbGN1bGF0ZSB0aGUgc2hhMyBvZiB0aGUgaW5wdXQgYnV0IGRvZXMgcmV0dXJuIHRoZSBoYXNoIHZhbHVlIGluc3RlYWQgb2YgbnVsbCBpZiBmb3IgZXhhbXBsZSBhIGVtcHR5IHN0cmluZyBpcyBwYXNzZWQuXG4gKiBAcGFyYW0gZGF0YSAtIHRoZSBpbnB1dCB0byBoYXNoXG4gKiBAcmV0dXJucyAtIHRoZSBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIGlucHV0XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25vc2xlLmxvZyh3ZWIzLnV0aWxzLnNoYTNSYXcoJ3dlYjMuanMnKSk7XG4gKiA+IDB4NjM2NjdlZmIxOTYxMDM5YzliYjBkNmVhN2E1YWJkZDIyM2EzYWNhN2RhYTUwNDRhZDg5NDIyNmUxZjgzOTE5YVxuICpcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMuc2hhM1JhdygnJykpO1xuICogPiAweGM1ZDI0NjAxODZmNzIzM2M5MjdlN2RiMmRjYzcwM2MwZTUwMGI2NTNjYTgyMjczYjdiZmFkODA0NWQ4NWE0NzBcbiAqIGBgYFxuICovXG5jb25zdCBzaGEzUmF3ID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCBoYXNoID0gKDAsIGV4cG9ydHMuc2hhMykoZGF0YSk7XG4gICAgaWYgKCgwLCB3ZWIzX3ZhbGlkYXRvcl8xLmlzTnVsbGlzaCkoaGFzaCkpIHtcbiAgICAgICAgcmV0dXJuIFNIQTNfRU1QVFlfQllURVM7XG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xufTtcbmV4cG9ydHMuc2hhM1JhdyA9IHNoYTNSYXc7XG4vKipcbiAqIEEgd3JhcHBlciBmb3IgZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2NhazI1NiB0byBhbGxvdyBoYXNoaW5nIGEgYHN0cmluZ2AgYW5kIGEgYGJpZ2ludGAgaW4gYWRkaXRpb24gdG8gYFVJbnQ4QXJyYXlgXG4gKiBAcGFyYW0gZGF0YSAtIHRoZSBpbnB1dCB0byBoYXNoXG4gKiBAcmV0dXJucyAtIHRoZSBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIGlucHV0XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zb2xlLmxvZyh3ZWIzLnV0aWxzLmtlY2NhazI1NldyYXBwZXIoJ3dlYjMuanMnKSk7XG4gKiA+IDB4NjM2NjdlZmIxOTYxMDM5YzliYjBkNmVhN2E1YWJkZDIyM2EzYWNhN2RhYTUwNDRhZDg5NDIyNmUxZjgzOTE5YVxuICpcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMua2VjY2FrMjU2V3JhcHBlcigxKSk7XG4gKiA+IDB4Yzg5ZWZkYWE1NGMwZjIwYzdhZGY2MTI4ODJkZjA5NTBmNWE5NTE2MzdlMDMwN2NkY2I0YzY3MmYyOThiOGJjNlxuICpcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMua2VjY2FrMjU2V3JhcHBlcigweGFmMTJmZCkpO1xuICogPiAweDM1ODY0MGZkNDcxOWZhOTIzNTI1ZDc0YWI1YWU4MGE1OTQzMDFhYmE1NTQzZTM0OTJiMDUyYmY0NTk4Yjc5NGNcbiAqIGBgYFxuICovXG5jb25zdCBrZWNjYWsyNTZXcmFwcGVyID0gKGRhdGEpID0+IHtcbiAgICBsZXQgcHJvY2Vzc2VkRGF0YTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdiaWdpbnQnIHx8IHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykge1xuICAgICAgICBwcm9jZXNzZWREYXRhID0gKDAsIHV0aWxzX2pzXzEudXRmOFRvQnl0ZXMpKGRhdGEudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcHJvY2Vzc2VkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgISgwLCB3ZWIzX3ZhbGlkYXRvcl8xLmlzSGV4U3RyaWN0KShkYXRhKSkge1xuICAgICAgICBwcm9jZXNzZWREYXRhID0gKDAsIHV0aWxzX2pzXzEudXRmOFRvQnl0ZXMpKGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc2VkRGF0YSA9ICgwLCBjb252ZXJ0ZXJzX2pzXzEuYnl0ZXNUb1VpbnQ4QXJyYXkpKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGNvbnZlcnRlcnNfanNfMS5ieXRlc1RvSGV4KSgoMCwga2VjY2FrX2pzXzEua2VjY2FrMjU2KSh3ZWIzX3ZhbGlkYXRvcl8xLnV0aWxzLmVuc3VyZUlmVWludDhBcnJheShwcm9jZXNzZWREYXRhKSkpO1xufTtcbmV4cG9ydHMua2VjY2FrMjU2V3JhcHBlciA9IGtlY2NhazI1NldyYXBwZXI7XG5leHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMua2VjY2FrMjU2V3JhcHBlcjtcbi8qKlxuICogcmV0dXJucyB0eXBlIGFuZCB2YWx1ZVxuICogQHBhcmFtIGFyZyAtIHRoZSBpbnB1dCB0byByZXR1cm4gdGhlIHR5cGUgYW5kIHZhbHVlXG4gKiBAcmV0dXJucyAtIHRoZSB0eXBlIGFuZCB2YWx1ZSBvZiB0aGUgaW5wdXRcbiAqL1xuY29uc3QgZ2V0VHlwZSA9IChhcmcpID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0b2RldGVjdGlvbiBvZiBhcnJheSB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICBsZXQgdHlwZTtcbiAgICBsZXQgdmFsdWU7XG4gICAgLy8gaWYgdHlwZSBpcyBnaXZlblxuICAgIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAoJ3QnIGluIGFyZyB8fCAndHlwZScgaW4gYXJnKSAmJlxuICAgICAgICAoJ3YnIGluIGFyZyB8fCAndmFsdWUnIGluIGFyZykpIHtcbiAgICAgICAgdHlwZSA9ICd0JyBpbiBhcmcgPyBhcmcudCA6IGFyZy50eXBlO1xuICAgICAgICB2YWx1ZSA9ICd2JyBpbiBhcmcgPyBhcmcudiA6IGFyZy52YWx1ZTtcbiAgICAgICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2JpZ2ludCcgPyAnaW50JyA6IHR5cGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBbJ2ludCcsIGFyZ107XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSB0cnkgdG8gZ3Vlc3MgdGhlIHR5cGVcbiAgICBlbHNlIHtcbiAgICAgICAgdHlwZSA9ICgwLCBjb252ZXJ0ZXJzX2pzXzEudG9IZXgpKGFyZywgdHJ1ZSk7XG4gICAgICAgIHZhbHVlID0gKDAsIGNvbnZlcnRlcnNfanNfMS50b0hleCkoYXJnKTtcbiAgICAgICAgaWYgKCF0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpICYmICF0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xuICAgICAgICAgICAgdHlwZSA9ICdieXRlcyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCh0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpIHx8IHR5cGUuc3RhcnRzV2l0aCgndWludCcpKSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICEvXigtKT8weC9pLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gKDAsIGNvbnZlcnRlcnNfanNfMS50b0JpZ0ludCkodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gW3R5cGUsIHZhbHVlXTtcbn07XG4vKipcbiAqIHJldHVybnMgdGhlIHR5cGUgd2l0aCBzaXplIGlmIHVpbnQgb3IgaW50XG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBpbnB1dCB0byByZXR1cm4gdGhlIHR5cGUgd2l0aCBzaXplXG4gKiBAcmV0dXJucyAtIHRoZSB0eXBlIHdpdGggc2l6ZSBvZiB0aGUgaW5wdXRcbiAqL1xuY29uc3QgZWxlbWVudGFyeU5hbWUgPSAobmFtZSkgPT4ge1xuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ2ludFsnKSkge1xuICAgICAgICByZXR1cm4gYGludDI1NiR7bmFtZS5zbGljZSgzKX1gO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2ludCcpIHtcbiAgICAgICAgcmV0dXJuICdpbnQyNTYnO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKCd1aW50WycpKSB7XG4gICAgICAgIHJldHVybiBgdWludDI1Nicke25hbWUuc2xpY2UoNCl9YDtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09ICd1aW50Jykge1xuICAgICAgICByZXR1cm4gJ3VpbnQyNTYnO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG4vKipcbiAqIHJldHVybnMgdGhlIHNpemUgb2YgdGhlIHZhbHVlIG9mIHR5cGUgJ2J5dGUnXG4gKi9cbmNvbnN0IHBhcnNlVHlwZU4gPSAodmFsdWUsIHR5cGVMZW5ndGgpID0+IHtcbiAgICBjb25zdCB0eXBlc2l6ZSA9IC9eKFxcZCspLiokLy5leGVjKHZhbHVlLnNsaWNlKHR5cGVMZW5ndGgpKTtcbiAgICByZXR1cm4gdHlwZXNpemUgPyBwYXJzZUludCh0eXBlc2l6ZVsxXSwgMTApIDogMDtcbn07XG4vKipcbiAqIHJldHVybnMgdGhlIGJpdCBsZW5ndGggb2YgdGhlIHZhbHVlXG4gKiBAcGFyYW0gdmFsdWUgLSB0aGUgaW5wdXQgdG8gcmV0dXJuIHRoZSBiaXQgbGVuZ3RoXG4gKiBAcmV0dXJucyAtIHRoZSBiaXQgbGVuZ3RoIG9mIHRoZSBpbnB1dFxuICovXG5jb25zdCBiaXRMZW5ndGggPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCB1cGRhdGVkVmFsID0gdmFsdWUudG9TdHJpbmcoMik7XG4gICAgcmV0dXJuIHVwZGF0ZWRWYWwubGVuZ3RoO1xufTtcbi8qKlxuICogUGFkcyB0aGUgdmFsdWUgYmFzZWQgb24gc2l6ZSBhbmQgdHlwZVxuICogcmV0dXJucyBhIHN0cmluZyBvZiB0aGUgcGFkZGVkIHZhbHVlXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSBpbnB1dCB0byBwYWRcbiAqIEByZXR1cm5zID0gdGhlIHBhZGRlZCB2YWx1ZVxuICovXG5jb25zdCBzb2xpZGl0eVBhY2sgPSAodHlwZSwgdmFsKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSB2YWwudG9TdHJpbmcoKTtcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb252ZXJ0ZXJzX2pzXzEudXRmOFRvSGV4KSh2YWwpO1xuICAgICAgICB0aHJvdyBuZXcgd2ViM19lcnJvcnNfMS5JbnZhbGlkU3RyaW5nRXJyb3IodmFsKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdib29sJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIHJldHVybiB2YWwgPyAnMDEnIDogJzAwJztcbiAgICAgICAgdGhyb3cgbmV3IHdlYjNfZXJyb3JzXzEuSW52YWxpZEJvb2xlYW5FcnJvcih2YWwpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgIGlmICghKDAsIHdlYjNfdmFsaWRhdG9yXzEuaXNBZGRyZXNzKSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB3ZWIzX2Vycm9yc18xLkludmFsaWRBZGRyZXNzRXJyb3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IGVsZW1lbnRhcnlOYW1lKHR5cGUpO1xuICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VUeXBlTihuYW1lLCAndWludCcubGVuZ3RoKTtcbiAgICAgICAgaWYgKHNpemUgJSA4IHx8IHNpemUgPCA4IHx8IHNpemUgPiAyNTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB3ZWIzX2Vycm9yc18xLkludmFsaWRTaXplRXJyb3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG51bSA9ICgwLCBjb252ZXJ0ZXJzX2pzXzEudG9OdW1iZXIpKHZhbHVlKTtcbiAgICAgICAgaWYgKGJpdExlbmd0aChudW0pID4gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHdlYjNfZXJyb3JzXzEuSW52YWxpZExhcmdlVmFsdWVFcnJvcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bSA8IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHdlYjNfZXJyb3JzXzEuSW52YWxpZFVuc2lnbmVkSW50ZWdlckVycm9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZSA/ICgwLCBzdHJpbmdfbWFuaXB1bGF0aW9uX2pzXzEubGVmdFBhZCkobnVtLnRvU3RyaW5nKDE2KSwgKHNpemUgLyA4KSAqIDIpIDogbnVtLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlVHlwZU4obmFtZSwgJ2ludCcubGVuZ3RoKTtcbiAgICAgICAgaWYgKHNpemUgJSA4IHx8IHNpemUgPCA4IHx8IHNpemUgPiAyNTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB3ZWIzX2Vycm9yc18xLkludmFsaWRTaXplRXJyb3IodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnVtID0gKDAsIGNvbnZlcnRlcnNfanNfMS50b051bWJlcikodmFsdWUpO1xuICAgICAgICBpZiAoYml0TGVuZ3RoKG51bSkgPiBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgd2ViM19lcnJvcnNfMS5JbnZhbGlkTGFyZ2VWYWx1ZUVycm9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtIDwgQmlnSW50KDApKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHN0cmluZ19tYW5pcHVsYXRpb25fanNfMS50b1R3b3NDb21wbGVtZW50KShudW0udG9TdHJpbmcoKSwgKHNpemUgLyA4KSAqIDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplID8gKDAsIHN0cmluZ19tYW5pcHVsYXRpb25fanNfMS5sZWZ0UGFkKShudW0udG9TdHJpbmcoMTYpLCBzaXplIC8gNCkgOiBudW0udG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2J5dGVzJykge1xuICAgICAgICBpZiAodmFsdWUucmVwbGFjZSgvXjB4L2ksICcnKS5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgd2ViM19lcnJvcnNfMS5JbnZhbGlkQnl0ZXNFcnJvcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5yZXBsYWNlKC9eMHgvaSwgJycpLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB3ZWIzX2Vycm9yc18xLkludmFsaWRCeXRlc0Vycm9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VUeXBlTih0eXBlLCAnYnl0ZXMnLmxlbmd0aCk7XG4gICAgICAgIGlmICghc2l6ZSB8fCBzaXplIDwgMSB8fCBzaXplID4gNjQgfHwgc2l6ZSA8IHZhbHVlLnJlcGxhY2UoL14weC9pLCAnJykubGVuZ3RoIC8gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHdlYjNfZXJyb3JzXzEuSW52YWxpZEJ5dGVzRXJyb3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgc3RyaW5nX21hbmlwdWxhdGlvbl9qc18xLnJpZ2h0UGFkKSh2YWx1ZSwgc2l6ZSAqIDIpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59O1xuLyoqXG4gKiByZXR1cm5zIGEgc3RyaW5nIG9mIHRoZSB0aWdodGx5IHBhY2tlZCB2YWx1ZSBnaXZlbiBiYXNlZCBvbiB0aGUgdHlwZVxuICogQHBhcmFtIGFyZyAtIHRoZSBpbnB1dCB0byByZXR1cm4gdGhlIHRpZ2h0bHkgcGFja2VkIHZhbHVlXG4gKiBAcmV0dXJucyAtIHRoZSB0aWdodGx5IHBhY2tlZCB2YWx1ZVxuICovXG5jb25zdCBwcm9jZXNzU29saWRpdHlFbmNvZGVQYWNrZWRBcmdzID0gKGFyZykgPT4ge1xuICAgIGNvbnN0IFt0eXBlLCB2YWxdID0gZ2V0VHlwZShhcmcpO1xuICAgIC8vIGFycmF5IGNhc2VcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIC8vIGdvIHRocm91Z2ggZWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBhbmQgdXNlIG1hcCBmdW5jdGlvbiB0byBjcmVhdGUgbmV3IGhleGFyZyBsaXN0XG4gICAgICAgIGNvbnN0IGhleEFyZyA9IHZhbC5tYXAoKHYpID0+IHNvbGlkaXR5UGFjayh0eXBlLCB2KS5yZXBsYWNlKCcweCcsICcnKSk7XG4gICAgICAgIHJldHVybiBoZXhBcmcuam9pbignJyk7XG4gICAgfVxuICAgIGNvbnN0IGhleEFyZyA9IHNvbGlkaXR5UGFjayh0eXBlLCB2YWwpO1xuICAgIHJldHVybiBoZXhBcmcucmVwbGFjZSgnMHgnLCAnJyk7XG59O1xuZXhwb3J0cy5wcm9jZXNzU29saWRpdHlFbmNvZGVQYWNrZWRBcmdzID0gcHJvY2Vzc1NvbGlkaXR5RW5jb2RlUGFja2VkQXJncztcbi8qKlxuICogRW5jb2RlIHBhY2tlZCBhcmd1bWVudHMgdG8gYSBoZXhzdHJpbmdcbiAqL1xuY29uc3QgZW5jb2RlUGFja2VkID0gKC4uLnZhbHVlcykgPT4ge1xuICAgIGNvbnN0IGhleEFyZ3MgPSB2YWx1ZXMubWFwKGV4cG9ydHMucHJvY2Vzc1NvbGlkaXR5RW5jb2RlUGFja2VkQXJncyk7XG4gICAgcmV0dXJuIGAweCR7aGV4QXJncy5qb2luKCcnKS50b0xvd2VyQ2FzZSgpfWA7XG59O1xuZXhwb3J0cy5lbmNvZGVQYWNrZWQgPSBlbmNvZGVQYWNrZWQ7XG4vKipcbiAqIFdpbGwgdGlnaHRseSBwYWNrIHZhbHVlcyBnaXZlbiBpbiB0aGUgc2FtZSB3YXkgc29saWRpdHkgd291bGQgdGhlbiBoYXNoLlxuICogcmV0dXJucyBhIGhhc2ggc3RyaW5nLCBvciBudWxsIGlmIGlucHV0IGlzIGVtcHR5XG4gKiBAcGFyYW0gdmFsdWVzIC0gdGhlIGlucHV0IHRvIHJldHVybiB0aGUgdGlnaHRseSBwYWNrZWQgdmFsdWVzXG4gKiBAcmV0dXJucyAtIHRoZSBrZWNjYWNrMjQ2IG9mIHRoZSB0aWdodGx5IHBhY2tlZCB2YWx1ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMuc29saWRpdHlTaGEzKHsgdHlwZTogXCJzdHJpbmdcIiwgdmFsdWU6IFwiMzEzMjMzMzRcIiB9KSk7XG4gKiA+IDB4ZjE1ZjhkYTJhZDI3ZTQ4NmQ2MzJkYzM3ZDI0OTEyZjYzNDM5ODkxOGQ2Zjk5MTNhMGEwZmY4NGUzODhiZTYyYlxuICogYGBgXG4gKi9cbmNvbnN0IHNvbGlkaXR5U2hhMyA9ICguLi52YWx1ZXMpID0+ICgwLCBleHBvcnRzLnNoYTMpKCgwLCBleHBvcnRzLmVuY29kZVBhY2tlZCkoLi4udmFsdWVzKSk7XG5leHBvcnRzLnNvbGlkaXR5U2hhMyA9IHNvbGlkaXR5U2hhMztcbi8qKlxuICogV2lsbCB0aWdodGx5IHBhY2sgdmFsdWVzIGdpdmVuIGluIHRoZSBzYW1lIHdheSBzb2xpZGl0eSB3b3VsZCB0aGVuIGhhc2guXG4gKiByZXR1cm5zIGEgaGFzaCBzdHJpbmcsIGlmIGlucHV0IGlzIGVtcHR5IHdpbGwgcmV0dXJuIGAweGM1ZDI0NjAxODZmNzIzM2M5MjdlN2RiMmRjYzcwM2MwZTUwMGI2NTNjYTgyMjczYjdiZmFkODA0NWQ4NWE0NzBgXG4gKiBAcGFyYW0gdmFsdWVzIC0gdGhlIGlucHV0IHRvIHJldHVybiB0aGUgdGlnaHRseSBwYWNrZWQgdmFsdWVzXG4gKiBAcmV0dXJucyAtIHRoZSBrZWNjYWNrMjQ2IG9mIHRoZSB0aWdodGx5IHBhY2tlZCB2YWx1ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMuc29saWRpdHlTaGEzUmF3KHsgdHlwZTogXCJzdHJpbmdcIiwgdmFsdWU6IFwiaGVsbG93b3JsZFwiIH0pKVxuICogPiAweGZhMjZkYjdjYTg1ZWFkMzk5MjE2ZTdjNjMxNmJjNTBlZDI0MzkzYzMxMjJiNTgyNzM1ZTdmM2IwZjkxYjkzZjBcbiAqIGBgYFxuICovXG5jb25zdCBzb2xpZGl0eVNoYTNSYXcgPSAoLi4udmFsdWVzKSA9PiAoMCwgZXhwb3J0cy5zaGEzUmF3KSgoMCwgZXhwb3J0cy5lbmNvZGVQYWNrZWQpKC4uLnZhbHVlcykpO1xuZXhwb3J0cy5zb2xpZGl0eVNoYTNSYXcgPSBzb2xpZGl0eVNoYTNSYXc7XG4vKipcbiAqIEdldCBzbG90IG51bWJlciBmb3Igc3RvcmFnZSBsb25nIHN0cmluZyBpbiBjb250cmFjdC4gQmFzaWNhbGx5IGZvciBnZXRTdG9yYWdlIG1ldGhvZFxuICogcmV0dXJucyBzbG90TnVtYmVyIHdoZXJlIHdpbGwgZGF0YSBwbGFjZWRcbiAqIEBwYXJhbSBtYWluU2xvdE51bWJlciAtIHRoZSBzbG90IG51bWJlciB3aGVyZSB3aWxsIGJlIHN0b3JlZCBoYXNoIG9mIGxvbmcgc3RyaW5nXG4gKiBAcmV0dXJucyAtIHRoZSBzbG90IG51bWJlciB3aGVyZSB3aWxsIGJlIHN0b3JlZCBsb25nIHN0cmluZ1xuICovXG5jb25zdCBnZXRTdG9yYWdlU2xvdE51bUZvckxvbmdTdHJpbmcgPSAobWFpblNsb3ROdW1iZXIpID0+ICgwLCBleHBvcnRzLnNoYTMpKGAweCR7KHR5cGVvZiBtYWluU2xvdE51bWJlciA9PT0gJ251bWJlcidcbiAgICA/IG1haW5TbG90TnVtYmVyLnRvU3RyaW5nKClcbiAgICA6IG1haW5TbG90TnVtYmVyKS5wYWRTdGFydCg2NCwgJzAnKX1gKTtcbmV4cG9ydHMuZ2V0U3RvcmFnZVNsb3ROdW1Gb3JMb25nU3RyaW5nID0gZ2V0U3RvcmFnZVNsb3ROdW1Gb3JMb25nU3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/hash.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/index.js":
/*!*********************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/index.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.jsonRpc = void 0;\n__exportStar(__webpack_require__(/*! ./converters.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/converters.js\"), exports);\n__exportStar(__webpack_require__(/*! ./event_emitter.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/event_emitter.js\"), exports);\n__exportStar(__webpack_require__(/*! ./validation.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/validation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./formatter.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/formatter.js\"), exports);\n__exportStar(__webpack_require__(/*! ./hash.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/hash.js\"), exports);\n__exportStar(__webpack_require__(/*! ./random.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/random.js\"), exports);\n__exportStar(__webpack_require__(/*! ./string_manipulation.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/string_manipulation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./objects.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/objects.js\"), exports);\n__exportStar(__webpack_require__(/*! ./promise_helpers.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/promise_helpers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./json_rpc.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/json_rpc.js\"), exports);\nexports.jsonRpc = __importStar(__webpack_require__(/*! ./json_rpc.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/json_rpc.js\"));\n__exportStar(__webpack_require__(/*! ./web3_deferred_promise.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/web3_deferred_promise.js\"), exports);\n__exportStar(__webpack_require__(/*! ./chunk_response_parser.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/chunk_response_parser.js\"), exports);\n__exportStar(__webpack_require__(/*! ./uuid.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/uuid.js\"), exports);\n__exportStar(__webpack_require__(/*! ./web3_eip1193_provider.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/web3_eip1193_provider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./socket_provider.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/socket_provider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./uint8array.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/uint8array.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsaUdBQWlCO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLGlHQUFpQjtBQUN0QyxhQUFhLG1CQUFPLENBQUMsK0ZBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxxRkFBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMseUZBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLG1IQUEwQjtBQUMvQyxhQUFhLG1CQUFPLENBQUMsMkZBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLDJHQUFzQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsNkZBQWU7QUFDcEMsZUFBZSxnQkFBZ0IsbUJBQU8sQ0FBQyw2RkFBZTtBQUN0RCxhQUFhLG1CQUFPLENBQUMsdUhBQTRCO0FBQ2pELGFBQWEsbUJBQU8sQ0FBQyx1SEFBNEI7QUFDakQsYUFBYSxtQkFBTyxDQUFDLHFGQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyx1SEFBNEI7QUFDakQsYUFBYSxtQkFBTyxDQUFDLDJHQUFzQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsaUdBQWlCO0FBQ3RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXNzdWVyX2hvbGRlcl92ZXJpZmllci8uL3NyYy9wYWdlcy9hcGkvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL2NvbW1vbmpzL2luZGV4LmpzPzNhYWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxud2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG5pdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbnRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4oYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG53ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG5idXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbllvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuanNvblJwYyA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb252ZXJ0ZXJzLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ldmVudF9lbWl0dGVyLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mb3JtYXR0ZXIuanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hhc2guanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JhbmRvbS5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RyaW5nX21hbmlwdWxhdGlvbi5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb2JqZWN0cy5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvbWlzZV9oZWxwZXJzLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9qc29uX3JwYy5qc1wiKSwgZXhwb3J0cyk7XG5leHBvcnRzLmpzb25ScGMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vanNvbl9ycGMuanNcIikpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dlYjNfZGVmZXJyZWRfcHJvbWlzZS5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2h1bmtfcmVzcG9uc2VfcGFyc2VyLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91dWlkLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi93ZWIzX2VpcDExOTNfcHJvdmlkZXIuanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NvY2tldF9wcm92aWRlci5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdWludDhhcnJheS5qc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/index.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/json_rpc.js":
/*!************************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/json_rpc.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isBatchRequest = exports.toBatchPayload = exports.toPayload = exports.setRequestIdStart = exports.isBatchResponse = exports.isValidResponse = exports.validateResponse = exports.isSubscriptionResult = exports.isResponseWithNotification = exports.isResponseWithError = exports.isResponseWithResult = exports.isResponseRpcError = void 0;\nconst web3_validator_1 = __webpack_require__(/*! web3-validator */ \"(api)/./src/pages/api/node_modules/web3-validator/lib/commonjs/index.js\");\nconst web3_errors_1 = __webpack_require__(/*! web3-errors */ \"(api)/./src/pages/api/node_modules/web3-errors/lib/commonjs/index.js\");\nconst uuid_js_1 = __webpack_require__(/*! ./uuid.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/uuid.js\");\n// check if code is a valid rpc server error code\nconst isResponseRpcError = (rpcError) => {\n    const errorCode = rpcError.error.code;\n    return web3_errors_1.rpcErrorsMap.has(errorCode) || (errorCode >= -32099 && errorCode <= -32000);\n};\nexports.isResponseRpcError = isResponseRpcError;\nconst isResponseWithResult = (response) => !Array.isArray(response) &&\n    !!response &&\n    response.jsonrpc === '2.0' &&\n    // JSON RPC consider \"null\" as valid response\n    'result' in response &&\n    (0, web3_validator_1.isNullish)(response.error) &&\n    (typeof response.id === 'number' || typeof response.id === 'string');\nexports.isResponseWithResult = isResponseWithResult;\n// To avoid circular package dependency, copied to code here. If you update this please update same function in `response_errors.ts`\nconst isResponseWithError = (response) => !Array.isArray(response) &&\n    response.jsonrpc === '2.0' &&\n    !!response &&\n    (0, web3_validator_1.isNullish)(response.result) &&\n    // JSON RPC consider \"null\" as valid response\n    'error' in response &&\n    (typeof response.id === 'number' || typeof response.id === 'string');\nexports.isResponseWithError = isResponseWithError;\nconst isResponseWithNotification = (response) => !Array.isArray(response) &&\n    !!response &&\n    response.jsonrpc === '2.0' &&\n    !(0, web3_validator_1.isNullish)(response.params) &&\n    !(0, web3_validator_1.isNullish)(response.method);\nexports.isResponseWithNotification = isResponseWithNotification;\nconst isSubscriptionResult = (response) => !Array.isArray(response) &&\n    !!response &&\n    response.jsonrpc === '2.0' &&\n    'id' in response &&\n    // JSON RPC consider \"null\" as valid response\n    'result' in response;\nexports.isSubscriptionResult = isSubscriptionResult;\nconst validateResponse = (response) => (0, exports.isResponseWithResult)(response) || (0, exports.isResponseWithError)(response);\nexports.validateResponse = validateResponse;\nconst isValidResponse = (response) => Array.isArray(response) ? response.every(exports.validateResponse) : (0, exports.validateResponse)(response);\nexports.isValidResponse = isValidResponse;\nconst isBatchResponse = (response) => Array.isArray(response) && response.length > 0 && (0, exports.isValidResponse)(response);\nexports.isBatchResponse = isBatchResponse;\n// internal optional variable to increment and use for the jsonrpc `id`\nlet requestIdSeed;\n/**\n * Optionally use to make the jsonrpc `id` start from a specific number.\n * Without calling this function, the `id` will be filled with a Uuid.\n * But after this being called with a number, the `id` will be a number staring from the provided `start` variable.\n * However, if `undefined` was passed to this function, the `id` will be a Uuid again.\n * @param start - a number to start incrementing from.\n * \tOr `undefined` to use a new Uuid (this is the default behavior)\n */\nconst setRequestIdStart = (start) => {\n    requestIdSeed = start;\n};\nexports.setRequestIdStart = setRequestIdStart;\nconst toPayload = (request) => {\n    var _a, _b, _c, _d;\n    if (typeof requestIdSeed !== 'undefined') {\n        requestIdSeed += 1;\n    }\n    return {\n        jsonrpc: (_a = request.jsonrpc) !== null && _a !== void 0 ? _a : '2.0',\n        id: (_c = (_b = request.id) !== null && _b !== void 0 ? _b : requestIdSeed) !== null && _c !== void 0 ? _c : (0, uuid_js_1.uuidV4)(),\n        method: request.method,\n        params: (_d = request.params) !== null && _d !== void 0 ? _d : undefined,\n    };\n};\nexports.toPayload = toPayload;\nconst toBatchPayload = (requests) => requests.map(request => (0, exports.toPayload)(request));\nexports.toBatchPayload = toBatchPayload;\nconst isBatchRequest = (request) => Array.isArray(request) && request.length > 0;\nexports.isBatchRequest = isBatchRequest;\n//# sourceMappingURL=json_rpc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9qc29uX3JwYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcsaUJBQWlCLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsNEJBQTRCLEdBQUcsa0NBQWtDLEdBQUcsMkJBQTJCLEdBQUcsNEJBQTRCLEdBQUcsMEJBQTBCO0FBQzVVLHlCQUF5QixtQkFBTyxDQUFDLCtGQUFnQjtBQUNqRCxzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXNzdWVyX2hvbGRlcl92ZXJpZmllci8uL3NyYy9wYWdlcy9hcGkvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL2NvbW1vbmpzL2pzb25fcnBjLmpzPzk3NmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxud2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG5pdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbnRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4oYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG53ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG5idXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbllvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNCYXRjaFJlcXVlc3QgPSBleHBvcnRzLnRvQmF0Y2hQYXlsb2FkID0gZXhwb3J0cy50b1BheWxvYWQgPSBleHBvcnRzLnNldFJlcXVlc3RJZFN0YXJ0ID0gZXhwb3J0cy5pc0JhdGNoUmVzcG9uc2UgPSBleHBvcnRzLmlzVmFsaWRSZXNwb25zZSA9IGV4cG9ydHMudmFsaWRhdGVSZXNwb25zZSA9IGV4cG9ydHMuaXNTdWJzY3JpcHRpb25SZXN1bHQgPSBleHBvcnRzLmlzUmVzcG9uc2VXaXRoTm90aWZpY2F0aW9uID0gZXhwb3J0cy5pc1Jlc3BvbnNlV2l0aEVycm9yID0gZXhwb3J0cy5pc1Jlc3BvbnNlV2l0aFJlc3VsdCA9IGV4cG9ydHMuaXNSZXNwb25zZVJwY0Vycm9yID0gdm9pZCAwO1xuY29uc3Qgd2ViM192YWxpZGF0b3JfMSA9IHJlcXVpcmUoXCJ3ZWIzLXZhbGlkYXRvclwiKTtcbmNvbnN0IHdlYjNfZXJyb3JzXzEgPSByZXF1aXJlKFwid2ViMy1lcnJvcnNcIik7XG5jb25zdCB1dWlkX2pzXzEgPSByZXF1aXJlKFwiLi91dWlkLmpzXCIpO1xuLy8gY2hlY2sgaWYgY29kZSBpcyBhIHZhbGlkIHJwYyBzZXJ2ZXIgZXJyb3IgY29kZVxuY29uc3QgaXNSZXNwb25zZVJwY0Vycm9yID0gKHJwY0Vycm9yKSA9PiB7XG4gICAgY29uc3QgZXJyb3JDb2RlID0gcnBjRXJyb3IuZXJyb3IuY29kZTtcbiAgICByZXR1cm4gd2ViM19lcnJvcnNfMS5ycGNFcnJvcnNNYXAuaGFzKGVycm9yQ29kZSkgfHwgKGVycm9yQ29kZSA+PSAtMzIwOTkgJiYgZXJyb3JDb2RlIDw9IC0zMjAwMCk7XG59O1xuZXhwb3J0cy5pc1Jlc3BvbnNlUnBjRXJyb3IgPSBpc1Jlc3BvbnNlUnBjRXJyb3I7XG5jb25zdCBpc1Jlc3BvbnNlV2l0aFJlc3VsdCA9IChyZXNwb25zZSkgPT4gIUFycmF5LmlzQXJyYXkocmVzcG9uc2UpICYmXG4gICAgISFyZXNwb25zZSAmJlxuICAgIHJlc3BvbnNlLmpzb25ycGMgPT09ICcyLjAnICYmXG4gICAgLy8gSlNPTiBSUEMgY29uc2lkZXIgXCJudWxsXCIgYXMgdmFsaWQgcmVzcG9uc2VcbiAgICAncmVzdWx0JyBpbiByZXNwb25zZSAmJlxuICAgICgwLCB3ZWIzX3ZhbGlkYXRvcl8xLmlzTnVsbGlzaCkocmVzcG9uc2UuZXJyb3IpICYmXG4gICAgKHR5cGVvZiByZXNwb25zZS5pZCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHJlc3BvbnNlLmlkID09PSAnc3RyaW5nJyk7XG5leHBvcnRzLmlzUmVzcG9uc2VXaXRoUmVzdWx0ID0gaXNSZXNwb25zZVdpdGhSZXN1bHQ7XG4vLyBUbyBhdm9pZCBjaXJjdWxhciBwYWNrYWdlIGRlcGVuZGVuY3ksIGNvcGllZCB0byBjb2RlIGhlcmUuIElmIHlvdSB1cGRhdGUgdGhpcyBwbGVhc2UgdXBkYXRlIHNhbWUgZnVuY3Rpb24gaW4gYHJlc3BvbnNlX2Vycm9ycy50c2BcbmNvbnN0IGlzUmVzcG9uc2VXaXRoRXJyb3IgPSAocmVzcG9uc2UpID0+ICFBcnJheS5pc0FycmF5KHJlc3BvbnNlKSAmJlxuICAgIHJlc3BvbnNlLmpzb25ycGMgPT09ICcyLjAnICYmXG4gICAgISFyZXNwb25zZSAmJlxuICAgICgwLCB3ZWIzX3ZhbGlkYXRvcl8xLmlzTnVsbGlzaCkocmVzcG9uc2UucmVzdWx0KSAmJlxuICAgIC8vIEpTT04gUlBDIGNvbnNpZGVyIFwibnVsbFwiIGFzIHZhbGlkIHJlc3BvbnNlXG4gICAgJ2Vycm9yJyBpbiByZXNwb25zZSAmJlxuICAgICh0eXBlb2YgcmVzcG9uc2UuaWQgPT09ICdudW1iZXInIHx8IHR5cGVvZiByZXNwb25zZS5pZCA9PT0gJ3N0cmluZycpO1xuZXhwb3J0cy5pc1Jlc3BvbnNlV2l0aEVycm9yID0gaXNSZXNwb25zZVdpdGhFcnJvcjtcbmNvbnN0IGlzUmVzcG9uc2VXaXRoTm90aWZpY2F0aW9uID0gKHJlc3BvbnNlKSA9PiAhQXJyYXkuaXNBcnJheShyZXNwb25zZSkgJiZcbiAgICAhIXJlc3BvbnNlICYmXG4gICAgcmVzcG9uc2UuanNvbnJwYyA9PT0gJzIuMCcgJiZcbiAgICAhKDAsIHdlYjNfdmFsaWRhdG9yXzEuaXNOdWxsaXNoKShyZXNwb25zZS5wYXJhbXMpICYmXG4gICAgISgwLCB3ZWIzX3ZhbGlkYXRvcl8xLmlzTnVsbGlzaCkocmVzcG9uc2UubWV0aG9kKTtcbmV4cG9ydHMuaXNSZXNwb25zZVdpdGhOb3RpZmljYXRpb24gPSBpc1Jlc3BvbnNlV2l0aE5vdGlmaWNhdGlvbjtcbmNvbnN0IGlzU3Vic2NyaXB0aW9uUmVzdWx0ID0gKHJlc3BvbnNlKSA9PiAhQXJyYXkuaXNBcnJheShyZXNwb25zZSkgJiZcbiAgICAhIXJlc3BvbnNlICYmXG4gICAgcmVzcG9uc2UuanNvbnJwYyA9PT0gJzIuMCcgJiZcbiAgICAnaWQnIGluIHJlc3BvbnNlICYmXG4gICAgLy8gSlNPTiBSUEMgY29uc2lkZXIgXCJudWxsXCIgYXMgdmFsaWQgcmVzcG9uc2VcbiAgICAncmVzdWx0JyBpbiByZXNwb25zZTtcbmV4cG9ydHMuaXNTdWJzY3JpcHRpb25SZXN1bHQgPSBpc1N1YnNjcmlwdGlvblJlc3VsdDtcbmNvbnN0IHZhbGlkYXRlUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+ICgwLCBleHBvcnRzLmlzUmVzcG9uc2VXaXRoUmVzdWx0KShyZXNwb25zZSkgfHwgKDAsIGV4cG9ydHMuaXNSZXNwb25zZVdpdGhFcnJvcikocmVzcG9uc2UpO1xuZXhwb3J0cy52YWxpZGF0ZVJlc3BvbnNlID0gdmFsaWRhdGVSZXNwb25zZTtcbmNvbnN0IGlzVmFsaWRSZXNwb25zZSA9IChyZXNwb25zZSkgPT4gQXJyYXkuaXNBcnJheShyZXNwb25zZSkgPyByZXNwb25zZS5ldmVyeShleHBvcnRzLnZhbGlkYXRlUmVzcG9uc2UpIDogKDAsIGV4cG9ydHMudmFsaWRhdGVSZXNwb25zZSkocmVzcG9uc2UpO1xuZXhwb3J0cy5pc1ZhbGlkUmVzcG9uc2UgPSBpc1ZhbGlkUmVzcG9uc2U7XG5jb25zdCBpc0JhdGNoUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+IEFycmF5LmlzQXJyYXkocmVzcG9uc2UpICYmIHJlc3BvbnNlLmxlbmd0aCA+IDAgJiYgKDAsIGV4cG9ydHMuaXNWYWxpZFJlc3BvbnNlKShyZXNwb25zZSk7XG5leHBvcnRzLmlzQmF0Y2hSZXNwb25zZSA9IGlzQmF0Y2hSZXNwb25zZTtcbi8vIGludGVybmFsIG9wdGlvbmFsIHZhcmlhYmxlIHRvIGluY3JlbWVudCBhbmQgdXNlIGZvciB0aGUganNvbnJwYyBgaWRgXG5sZXQgcmVxdWVzdElkU2VlZDtcbi8qKlxuICogT3B0aW9uYWxseSB1c2UgdG8gbWFrZSB0aGUganNvbnJwYyBgaWRgIHN0YXJ0IGZyb20gYSBzcGVjaWZpYyBudW1iZXIuXG4gKiBXaXRob3V0IGNhbGxpbmcgdGhpcyBmdW5jdGlvbiwgdGhlIGBpZGAgd2lsbCBiZSBmaWxsZWQgd2l0aCBhIFV1aWQuXG4gKiBCdXQgYWZ0ZXIgdGhpcyBiZWluZyBjYWxsZWQgd2l0aCBhIG51bWJlciwgdGhlIGBpZGAgd2lsbCBiZSBhIG51bWJlciBzdGFyaW5nIGZyb20gdGhlIHByb3ZpZGVkIGBzdGFydGAgdmFyaWFibGUuXG4gKiBIb3dldmVyLCBpZiBgdW5kZWZpbmVkYCB3YXMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24sIHRoZSBgaWRgIHdpbGwgYmUgYSBVdWlkIGFnYWluLlxuICogQHBhcmFtIHN0YXJ0IC0gYSBudW1iZXIgdG8gc3RhcnQgaW5jcmVtZW50aW5nIGZyb20uXG4gKiBcdE9yIGB1bmRlZmluZWRgIHRvIHVzZSBhIG5ldyBVdWlkICh0aGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yKVxuICovXG5jb25zdCBzZXRSZXF1ZXN0SWRTdGFydCA9IChzdGFydCkgPT4ge1xuICAgIHJlcXVlc3RJZFNlZWQgPSBzdGFydDtcbn07XG5leHBvcnRzLnNldFJlcXVlc3RJZFN0YXJ0ID0gc2V0UmVxdWVzdElkU3RhcnQ7XG5jb25zdCB0b1BheWxvYWQgPSAocmVxdWVzdCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3RJZFNlZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlcXVlc3RJZFNlZWQgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogKF9hID0gcmVxdWVzdC5qc29ucnBjKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnMi4wJyxcbiAgICAgICAgaWQ6IChfYyA9IChfYiA9IHJlcXVlc3QuaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHJlcXVlc3RJZFNlZWQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICgwLCB1dWlkX2pzXzEudXVpZFY0KSgpLFxuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXJhbXM6IChfZCA9IHJlcXVlc3QucGFyYW1zKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB1bmRlZmluZWQsXG4gICAgfTtcbn07XG5leHBvcnRzLnRvUGF5bG9hZCA9IHRvUGF5bG9hZDtcbmNvbnN0IHRvQmF0Y2hQYXlsb2FkID0gKHJlcXVlc3RzKSA9PiByZXF1ZXN0cy5tYXAocmVxdWVzdCA9PiAoMCwgZXhwb3J0cy50b1BheWxvYWQpKHJlcXVlc3QpKTtcbmV4cG9ydHMudG9CYXRjaFBheWxvYWQgPSB0b0JhdGNoUGF5bG9hZDtcbmNvbnN0IGlzQmF0Y2hSZXF1ZXN0ID0gKHJlcXVlc3QpID0+IEFycmF5LmlzQXJyYXkocmVxdWVzdCkgJiYgcmVxdWVzdC5sZW5ndGggPiAwO1xuZXhwb3J0cy5pc0JhdGNoUmVxdWVzdCA9IGlzQmF0Y2hSZXF1ZXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbl9ycGMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/json_rpc.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/objects.js":
/*!***********************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/objects.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mergeDeep = void 0;\nconst web3_types_1 = __webpack_require__(/*! web3-types */ \"(api)/./src/pages/api/node_modules/web3-types/lib/commonjs/index.js\");\nconst web3_validator_1 = __webpack_require__(/*! web3-validator */ \"(api)/./src/pages/api/node_modules/web3-validator/lib/commonjs/index.js\");\nconst isIterable = (item) => typeof item === 'object' &&\n    !(0, web3_validator_1.isNullish)(item) &&\n    !Array.isArray(item) &&\n    !(item instanceof web3_types_1.TypedArray);\n// The following code is a derivative work of the code from the \"LiskHQ/lisk-sdk\" project,\n// which is licensed under Apache version 2.\n/**\n * Deep merge two objects.\n * @param destination - The destination object.\n * @param sources - An array of source objects.\n * @returns - The merged object.\n */\nconst mergeDeep = (destination, ...sources) => {\n    const result = destination; // clone deep here\n    if (!isIterable(result)) {\n        return result;\n    }\n    for (const src of sources) {\n        // eslint-disable-next-line no-restricted-syntax\n        for (const key in src) {\n            if (isIterable(src[key])) {\n                if (!result[key]) {\n                    result[key] = {};\n                }\n                (0, exports.mergeDeep)(result[key], src[key]);\n            }\n            else if (!(0, web3_validator_1.isNullish)(src[key]) && Object.hasOwnProperty.call(src, key)) {\n                if (Array.isArray(src[key]) || src[key] instanceof web3_types_1.TypedArray) {\n                    result[key] = src[key].slice(0);\n                }\n                else {\n                    result[key] = src[key];\n                }\n            }\n        }\n    }\n    return result;\n};\nexports.mergeDeep = mergeDeep;\n//# sourceMappingURL=objects.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9vYmplY3RzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIscUJBQXFCLG1CQUFPLENBQUMsdUZBQVk7QUFDekMseUJBQXlCLG1CQUFPLENBQUMsK0ZBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL2lzc3Vlcl9ob2xkZXJfdmVyaWZpZXIvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9vYmplY3RzLmpzPzU0MWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxud2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG5pdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbnRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4oYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG53ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG5idXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbllvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWVyZ2VEZWVwID0gdm9pZCAwO1xuY29uc3Qgd2ViM190eXBlc18xID0gcmVxdWlyZShcIndlYjMtdHlwZXNcIik7XG5jb25zdCB3ZWIzX3ZhbGlkYXRvcl8xID0gcmVxdWlyZShcIndlYjMtdmFsaWRhdG9yXCIpO1xuY29uc3QgaXNJdGVyYWJsZSA9IChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiZcbiAgICAhKDAsIHdlYjNfdmFsaWRhdG9yXzEuaXNOdWxsaXNoKShpdGVtKSAmJlxuICAgICFBcnJheS5pc0FycmF5KGl0ZW0pICYmXG4gICAgIShpdGVtIGluc3RhbmNlb2Ygd2ViM190eXBlc18xLlR5cGVkQXJyYXkpO1xuLy8gVGhlIGZvbGxvd2luZyBjb2RlIGlzIGEgZGVyaXZhdGl2ZSB3b3JrIG9mIHRoZSBjb2RlIGZyb20gdGhlIFwiTGlza0hRL2xpc2stc2RrXCIgcHJvamVjdCxcbi8vIHdoaWNoIGlzIGxpY2Vuc2VkIHVuZGVyIEFwYWNoZSB2ZXJzaW9uIDIuXG4vKipcbiAqIERlZXAgbWVyZ2UgdHdvIG9iamVjdHMuXG4gKiBAcGFyYW0gZGVzdGluYXRpb24gLSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHNvdXJjZXMgLSBBbiBhcnJheSBvZiBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIC0gVGhlIG1lcmdlZCBvYmplY3QuXG4gKi9cbmNvbnN0IG1lcmdlRGVlcCA9IChkZXN0aW5hdGlvbiwgLi4uc291cmNlcykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGRlc3RpbmF0aW9uOyAvLyBjbG9uZSBkZWVwIGhlcmVcbiAgICBpZiAoIWlzSXRlcmFibGUocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNyYyBvZiBzb3VyY2VzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzcmMpIHtcbiAgICAgICAgICAgIGlmIChpc0l0ZXJhYmxlKHNyY1trZXldKSkge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0W2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKDAsIGV4cG9ydHMubWVyZ2VEZWVwKShyZXN1bHRba2V5XSwgc3JjW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoISgwLCB3ZWIzX3ZhbGlkYXRvcl8xLmlzTnVsbGlzaCkoc3JjW2tleV0pICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywga2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNyY1trZXldKSB8fCBzcmNba2V5XSBpbnN0YW5jZW9mIHdlYjNfdHlwZXNfMS5UeXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gc3JjW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHNyY1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMubWVyZ2VEZWVwID0gbWVyZ2VEZWVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/objects.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/promise_helpers.js":
/*!*******************************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/promise_helpers.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rejectIfConditionAtInterval = exports.rejectIfTimeout = exports.pollTillDefined = exports.pollTillDefinedAndReturnIntervalId = exports.waitWithTimeout = exports.isPromise = void 0;\nconst web3_validator_1 = __webpack_require__(/*! web3-validator */ \"(api)/./src/pages/api/node_modules/web3-validator/lib/commonjs/index.js\");\n/**\n * An alternative to the node function `isPromise` that exists in `util/types` because it is not available on the browser.\n * @param object - to check if it is a `Promise`\n * @returns `true` if it is an `object` or a `function` that has a `then` function. And returns `false` otherwise.\n */\nfunction isPromise(object) {\n    return ((typeof object === 'object' || typeof object === 'function') &&\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        typeof object.then === 'function');\n}\nexports.isPromise = isPromise;\n/**\n * Wait for a promise but interrupt it if it did not resolve within a given timeout.\n * If the timeout reached, before the promise code resolve, either throw an error if an error object was provided, or return `undefined`.\n * @param awaitable - The promise or function to wait for.\n * @param timeout - The timeout in milliseconds.\n * @param error - (Optional) The error to throw if the timeout reached.\n */\nfunction waitWithTimeout(awaitable, timeout, error) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let timeoutId;\n        const result = yield Promise.race([\n            awaitable instanceof Promise ? awaitable : awaitable(),\n            new Promise((resolve, reject) => {\n                timeoutId = setTimeout(() => (error ? reject(error) : resolve(undefined)), timeout);\n            }),\n        ]);\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        if (result instanceof Error) {\n            throw result;\n        }\n        return result;\n    });\n}\nexports.waitWithTimeout = waitWithTimeout;\n/**\n * Repeatedly calls an async function with a given interval until the result of the function is defined (not undefined or null),\n * or until a timeout is reached. It returns promise and intervalId.\n * @param func - The function to call.\n * @param interval - The interval in milliseconds.\n */\nfunction pollTillDefinedAndReturnIntervalId(func, interval) {\n    let intervalId;\n    const polledRes = new Promise((resolve, reject) => {\n        intervalId = setInterval(function intervalCallbackFunc() {\n            (() => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const res = yield waitWithTimeout(func, interval);\n                    if (!(0, web3_validator_1.isNullish)(res)) {\n                        clearInterval(intervalId);\n                        resolve(res);\n                    }\n                }\n                catch (error) {\n                    clearInterval(intervalId);\n                    reject(error);\n                }\n            }))();\n            return intervalCallbackFunc;\n        }() // this will immediate invoke first call\n        , interval);\n    });\n    return [polledRes, intervalId];\n}\nexports.pollTillDefinedAndReturnIntervalId = pollTillDefinedAndReturnIntervalId;\n/**\n * Repeatedly calls an async function with a given interval until the result of the function is defined (not undefined or null),\n * or until a timeout is reached.\n * pollTillDefinedAndReturnIntervalId() function should be used instead of pollTillDefined if you need IntervalId in result.\n * This function will be deprecated in next major release so use pollTillDefinedAndReturnIntervalId().\n * @param func - The function to call.\n * @param interval - The interval in milliseconds.\n */\nfunction pollTillDefined(func, interval) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return pollTillDefinedAndReturnIntervalId(func, interval)[0];\n    });\n}\nexports.pollTillDefined = pollTillDefined;\n/**\n * Enforce a timeout on a promise, so that it can be rejected if it takes too long to complete\n * @param timeout - The timeout to enforced in milliseconds.\n * @param error - The error to throw if the timeout is reached.\n * @returns A tuple of the timeout id and the promise that will be rejected if the timeout is reached.\n *\n * @example\n * ```ts\n * const [timerId, promise] = web3.utils.rejectIfTimeout(100, new Error('time out'));\n * ```\n */\nfunction rejectIfTimeout(timeout, error) {\n    let timeoutId;\n    const rejectOnTimeout = new Promise((_, reject) => {\n        timeoutId = setTimeout(() => {\n            reject(error);\n        }, timeout);\n    });\n    return [timeoutId, rejectOnTimeout];\n}\nexports.rejectIfTimeout = rejectIfTimeout;\n/**\n * Sets an interval that repeatedly executes the given cond function with the specified interval between each call.\n * If the condition is met, the interval is cleared and a Promise that rejects with the returned value is returned.\n * @param cond - The function/confition to call.\n * @param interval - The interval in milliseconds.\n * @returns - an array with the interval ID and the Promise.\n */\nfunction rejectIfConditionAtInterval(cond, interval) {\n    let intervalId;\n    const rejectIfCondition = new Promise((_, reject) => {\n        intervalId = setInterval(() => {\n            (() => __awaiter(this, void 0, void 0, function* () {\n                const error = yield cond();\n                if (error) {\n                    clearInterval(intervalId);\n                    reject(error);\n                }\n            }))();\n        }, interval);\n    });\n    return [intervalId, rejectIfCondition];\n}\nexports.rejectIfConditionAtInterval = rejectIfConditionAtInterval;\n//# sourceMappingURL=promise_helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9wcm9taXNlX2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUMsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRywwQ0FBMEMsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUI7QUFDbEwseUJBQXlCLG1CQUFPLENBQUMsK0ZBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3N1ZXJfaG9sZGVyX3ZlcmlmaWVyLy4vc3JjL3BhZ2VzL2FwaS9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvY29tbW9uanMvcHJvbWlzZV9oZWxwZXJzLmpzPzE0YjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxud2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG5pdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbnRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4oYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG53ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG5idXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbllvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWplY3RJZkNvbmRpdGlvbkF0SW50ZXJ2YWwgPSBleHBvcnRzLnJlamVjdElmVGltZW91dCA9IGV4cG9ydHMucG9sbFRpbGxEZWZpbmVkID0gZXhwb3J0cy5wb2xsVGlsbERlZmluZWRBbmRSZXR1cm5JbnRlcnZhbElkID0gZXhwb3J0cy53YWl0V2l0aFRpbWVvdXQgPSBleHBvcnRzLmlzUHJvbWlzZSA9IHZvaWQgMDtcbmNvbnN0IHdlYjNfdmFsaWRhdG9yXzEgPSByZXF1aXJlKFwid2ViMy12YWxpZGF0b3JcIik7XG4vKipcbiAqIEFuIGFsdGVybmF0aXZlIHRvIHRoZSBub2RlIGZ1bmN0aW9uIGBpc1Byb21pc2VgIHRoYXQgZXhpc3RzIGluIGB1dGlsL3R5cGVzYCBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIGJyb3dzZXIuXG4gKiBAcGFyYW0gb2JqZWN0IC0gdG8gY2hlY2sgaWYgaXQgaXMgYSBgUHJvbWlzZWBcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBpdCBpcyBhbiBgb2JqZWN0YCBvciBhIGBmdW5jdGlvbmAgdGhhdCBoYXMgYSBgdGhlbmAgZnVuY3Rpb24uIEFuZCByZXR1cm5zIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuICgodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICB0eXBlb2Ygb2JqZWN0LnRoZW4gPT09ICdmdW5jdGlvbicpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG4vKipcbiAqIFdhaXQgZm9yIGEgcHJvbWlzZSBidXQgaW50ZXJydXB0IGl0IGlmIGl0IGRpZCBub3QgcmVzb2x2ZSB3aXRoaW4gYSBnaXZlbiB0aW1lb3V0LlxuICogSWYgdGhlIHRpbWVvdXQgcmVhY2hlZCwgYmVmb3JlIHRoZSBwcm9taXNlIGNvZGUgcmVzb2x2ZSwgZWl0aGVyIHRocm93IGFuIGVycm9yIGlmIGFuIGVycm9yIG9iamVjdCB3YXMgcHJvdmlkZWQsIG9yIHJldHVybiBgdW5kZWZpbmVkYC5cbiAqIEBwYXJhbSBhd2FpdGFibGUgLSBUaGUgcHJvbWlzZSBvciBmdW5jdGlvbiB0byB3YWl0IGZvci5cbiAqIEBwYXJhbSB0aW1lb3V0IC0gVGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIGVycm9yIC0gKE9wdGlvbmFsKSBUaGUgZXJyb3IgdG8gdGhyb3cgaWYgdGhlIHRpbWVvdXQgcmVhY2hlZC5cbiAqL1xuZnVuY3Rpb24gd2FpdFdpdGhUaW1lb3V0KGF3YWl0YWJsZSwgdGltZW91dCwgZXJyb3IpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsZXQgdGltZW91dElkO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgYXdhaXRhYmxlIGluc3RhbmNlb2YgUHJvbWlzZSA/IGF3YWl0YWJsZSA6IGF3YWl0YWJsZSgpLFxuICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gKGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUodW5kZWZpbmVkKSksIHRpbWVvdXQpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxuZXhwb3J0cy53YWl0V2l0aFRpbWVvdXQgPSB3YWl0V2l0aFRpbWVvdXQ7XG4vKipcbiAqIFJlcGVhdGVkbHkgY2FsbHMgYW4gYXN5bmMgZnVuY3Rpb24gd2l0aCBhIGdpdmVuIGludGVydmFsIHVudGlsIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGlzIGRlZmluZWQgKG5vdCB1bmRlZmluZWQgb3IgbnVsbCksXG4gKiBvciB1bnRpbCBhIHRpbWVvdXQgaXMgcmVhY2hlZC4gSXQgcmV0dXJucyBwcm9taXNlIGFuZCBpbnRlcnZhbElkLlxuICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAqIEBwYXJhbSBpbnRlcnZhbCAtIFRoZSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIHBvbGxUaWxsRGVmaW5lZEFuZFJldHVybkludGVydmFsSWQoZnVuYywgaW50ZXJ2YWwpIHtcbiAgICBsZXQgaW50ZXJ2YWxJZDtcbiAgICBjb25zdCBwb2xsZWRSZXMgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiBpbnRlcnZhbENhbGxiYWNrRnVuYygpIHtcbiAgICAgICAgICAgICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0geWllbGQgd2FpdFdpdGhUaW1lb3V0KGZ1bmMsIGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgd2ViM192YWxpZGF0b3JfMS5pc051bGxpc2gpKHJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpKCk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWxDYWxsYmFja0Z1bmM7XG4gICAgICAgIH0oKSAvLyB0aGlzIHdpbGwgaW1tZWRpYXRlIGludm9rZSBmaXJzdCBjYWxsXG4gICAgICAgICwgaW50ZXJ2YWwpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcG9sbGVkUmVzLCBpbnRlcnZhbElkXTtcbn1cbmV4cG9ydHMucG9sbFRpbGxEZWZpbmVkQW5kUmV0dXJuSW50ZXJ2YWxJZCA9IHBvbGxUaWxsRGVmaW5lZEFuZFJldHVybkludGVydmFsSWQ7XG4vKipcbiAqIFJlcGVhdGVkbHkgY2FsbHMgYW4gYXN5bmMgZnVuY3Rpb24gd2l0aCBhIGdpdmVuIGludGVydmFsIHVudGlsIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGlzIGRlZmluZWQgKG5vdCB1bmRlZmluZWQgb3IgbnVsbCksXG4gKiBvciB1bnRpbCBhIHRpbWVvdXQgaXMgcmVhY2hlZC5cbiAqIHBvbGxUaWxsRGVmaW5lZEFuZFJldHVybkludGVydmFsSWQoKSBmdW5jdGlvbiBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIG9mIHBvbGxUaWxsRGVmaW5lZCBpZiB5b3UgbmVlZCBJbnRlcnZhbElkIGluIHJlc3VsdC5cbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBkZXByZWNhdGVkIGluIG5leHQgbWFqb3IgcmVsZWFzZSBzbyB1c2UgcG9sbFRpbGxEZWZpbmVkQW5kUmV0dXJuSW50ZXJ2YWxJZCgpLlxuICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAqIEBwYXJhbSBpbnRlcnZhbCAtIFRoZSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIHBvbGxUaWxsRGVmaW5lZChmdW5jLCBpbnRlcnZhbCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiBwb2xsVGlsbERlZmluZWRBbmRSZXR1cm5JbnRlcnZhbElkKGZ1bmMsIGludGVydmFsKVswXTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucG9sbFRpbGxEZWZpbmVkID0gcG9sbFRpbGxEZWZpbmVkO1xuLyoqXG4gKiBFbmZvcmNlIGEgdGltZW91dCBvbiBhIHByb21pc2UsIHNvIHRoYXQgaXQgY2FuIGJlIHJlamVjdGVkIGlmIGl0IHRha2VzIHRvbyBsb25nIHRvIGNvbXBsZXRlXG4gKiBAcGFyYW0gdGltZW91dCAtIFRoZSB0aW1lb3V0IHRvIGVuZm9yY2VkIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byB0aHJvdyBpZiB0aGUgdGltZW91dCBpcyByZWFjaGVkLlxuICogQHJldHVybnMgQSB0dXBsZSBvZiB0aGUgdGltZW91dCBpZCBhbmQgdGhlIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlamVjdGVkIGlmIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBbdGltZXJJZCwgcHJvbWlzZV0gPSB3ZWIzLnV0aWxzLnJlamVjdElmVGltZW91dCgxMDAsIG5ldyBFcnJvcigndGltZSBvdXQnKSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gcmVqZWN0SWZUaW1lb3V0KHRpbWVvdXQsIGVycm9yKSB7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBjb25zdCByZWplY3RPblRpbWVvdXQgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFt0aW1lb3V0SWQsIHJlamVjdE9uVGltZW91dF07XG59XG5leHBvcnRzLnJlamVjdElmVGltZW91dCA9IHJlamVjdElmVGltZW91dDtcbi8qKlxuICogU2V0cyBhbiBpbnRlcnZhbCB0aGF0IHJlcGVhdGVkbHkgZXhlY3V0ZXMgdGhlIGdpdmVuIGNvbmQgZnVuY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIGludGVydmFsIGJldHdlZW4gZWFjaCBjYWxsLlxuICogSWYgdGhlIGNvbmRpdGlvbiBpcyBtZXQsIHRoZSBpbnRlcnZhbCBpcyBjbGVhcmVkIGFuZCBhIFByb21pc2UgdGhhdCByZWplY3RzIHdpdGggdGhlIHJldHVybmVkIHZhbHVlIGlzIHJldHVybmVkLlxuICogQHBhcmFtIGNvbmQgLSBUaGUgZnVuY3Rpb24vY29uZml0aW9uIHRvIGNhbGwuXG4gKiBAcGFyYW0gaW50ZXJ2YWwgLSBUaGUgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzLlxuICogQHJldHVybnMgLSBhbiBhcnJheSB3aXRoIHRoZSBpbnRlcnZhbCBJRCBhbmQgdGhlIFByb21pc2UuXG4gKi9cbmZ1bmN0aW9uIHJlamVjdElmQ29uZGl0aW9uQXRJbnRlcnZhbChjb25kLCBpbnRlcnZhbCkge1xuICAgIGxldCBpbnRlcnZhbElkO1xuICAgIGNvbnN0IHJlamVjdElmQ29uZGl0aW9uID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHlpZWxkIGNvbmQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkoKTtcbiAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgIH0pO1xuICAgIHJldHVybiBbaW50ZXJ2YWxJZCwgcmVqZWN0SWZDb25kaXRpb25dO1xufVxuZXhwb3J0cy5yZWplY3RJZkNvbmRpdGlvbkF0SW50ZXJ2YWwgPSByZWplY3RJZkNvbmRpdGlvbkF0SW50ZXJ2YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9taXNlX2hlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/promise_helpers.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/random.js":
/*!**********************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/random.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomHex = exports.randomBytes = void 0;\n/**\n * @module Utils\n */\nconst random_js_1 = __webpack_require__(/*! ethereum-cryptography/random.js */ \"(api)/./src/pages/api/node_modules/ethereum-cryptography/random.js\");\nconst converters_js_1 = __webpack_require__(/*! ./converters.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/converters.js\");\n/**\n * Returns a random byte array by the given bytes size\n * @param size - The size of the random byte array returned\n * @returns - random byte array\n *\n * @example\n * ```ts\n * console.log(web3.utils.randomBytes(32));\n * > Uint8Array(32) [\n *       93, 172, 226,  32,  33, 176, 156, 156,\n *       182,  30, 240,   2,  69,  96, 174, 197,\n *       33, 136, 194, 241, 197, 156, 110, 111,\n *       66,  87,  17,  88,  67,  48, 245, 183\n *    ]\n * ```\n */\nconst randomBytes = (size) => (0, random_js_1.getRandomBytesSync)(size);\nexports.randomBytes = randomBytes;\n/**\n * Returns a random hex string by the given bytes size\n * @param byteSize - The size of the random hex string returned\n * @returns - random hex string\n *\n * ```ts\n * console.log(web3.utils.randomHex(32));\n * > 0x139f5b88b72a25eab053d3b57fe1f8a9dbc62a526b1cb1774d0d7db1c3e7ce9e\n * ```\n */\nconst randomHex = (byteSize) => (0, converters_js_1.bytesToHex)((0, exports.randomBytes)(byteSize));\nexports.randomHex = randomHex;\n//# sourceMappingURL=random.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9yYW5kb20uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQywyR0FBaUM7QUFDN0Qsd0JBQXdCLG1CQUFPLENBQUMsaUdBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL2lzc3Vlcl9ob2xkZXJfdmVyaWZpZXIvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9yYW5kb20uanM/ZGM4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG5UaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG53ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbml0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxudGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbihhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbndlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbmJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG5NRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG5HTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG5hbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yYW5kb21IZXggPSBleHBvcnRzLnJhbmRvbUJ5dGVzID0gdm9pZCAwO1xuLyoqXG4gKiBAbW9kdWxlIFV0aWxzXG4gKi9cbmNvbnN0IHJhbmRvbV9qc18xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9yYW5kb20uanNcIik7XG5jb25zdCBjb252ZXJ0ZXJzX2pzXzEgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzLmpzXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGJ5dGUgYXJyYXkgYnkgdGhlIGdpdmVuIGJ5dGVzIHNpemVcbiAqIEBwYXJhbSBzaXplIC0gVGhlIHNpemUgb2YgdGhlIHJhbmRvbSBieXRlIGFycmF5IHJldHVybmVkXG4gKiBAcmV0dXJucyAtIHJhbmRvbSBieXRlIGFycmF5XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zb2xlLmxvZyh3ZWIzLnV0aWxzLnJhbmRvbUJ5dGVzKDMyKSk7XG4gKiA+IFVpbnQ4QXJyYXkoMzIpIFtcbiAqICAgICAgIDkzLCAxNzIsIDIyNiwgIDMyLCAgMzMsIDE3NiwgMTU2LCAxNTYsXG4gKiAgICAgICAxODIsICAzMCwgMjQwLCAgIDIsICA2OSwgIDk2LCAxNzQsIDE5NyxcbiAqICAgICAgIDMzLCAxMzYsIDE5NCwgMjQxLCAxOTcsIDE1NiwgMTEwLCAxMTEsXG4gKiAgICAgICA2NiwgIDg3LCAgMTcsICA4OCwgIDY3LCAgNDgsIDI0NSwgMTgzXG4gKiAgICBdXG4gKiBgYGBcbiAqL1xuY29uc3QgcmFuZG9tQnl0ZXMgPSAoc2l6ZSkgPT4gKDAsIHJhbmRvbV9qc18xLmdldFJhbmRvbUJ5dGVzU3luYykoc2l6ZSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaGV4IHN0cmluZyBieSB0aGUgZ2l2ZW4gYnl0ZXMgc2l6ZVxuICogQHBhcmFtIGJ5dGVTaXplIC0gVGhlIHNpemUgb2YgdGhlIHJhbmRvbSBoZXggc3RyaW5nIHJldHVybmVkXG4gKiBAcmV0dXJucyAtIHJhbmRvbSBoZXggc3RyaW5nXG4gKlxuICogYGBgdHNcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMucmFuZG9tSGV4KDMyKSk7XG4gKiA+IDB4MTM5ZjViODhiNzJhMjVlYWIwNTNkM2I1N2ZlMWY4YTlkYmM2MmE1MjZiMWNiMTc3NGQwZDdkYjFjM2U3Y2U5ZVxuICogYGBgXG4gKi9cbmNvbnN0IHJhbmRvbUhleCA9IChieXRlU2l6ZSkgPT4gKDAsIGNvbnZlcnRlcnNfanNfMS5ieXRlc1RvSGV4KSgoMCwgZXhwb3J0cy5yYW5kb21CeXRlcykoYnl0ZVNpemUpKTtcbmV4cG9ydHMucmFuZG9tSGV4ID0gcmFuZG9tSGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZG9tLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/random.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/socket_provider.js":
/*!*******************************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/socket_provider.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SocketProvider = void 0;\nconst web3_errors_1 = __webpack_require__(/*! web3-errors */ \"(api)/./src/pages/api/node_modules/web3-errors/lib/commonjs/index.js\");\nconst web3_eip1193_provider_js_1 = __webpack_require__(/*! ./web3_eip1193_provider.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/web3_eip1193_provider.js\");\nconst chunk_response_parser_js_1 = __webpack_require__(/*! ./chunk_response_parser.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/chunk_response_parser.js\");\nconst validation_js_1 = __webpack_require__(/*! ./validation.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/validation.js\");\nconst web3_deferred_promise_js_1 = __webpack_require__(/*! ./web3_deferred_promise.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/web3_deferred_promise.js\");\nconst jsonRpc = __importStar(__webpack_require__(/*! ./json_rpc.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/json_rpc.js\"));\nconst DEFAULT_RECONNECTION_OPTIONS = {\n    autoReconnect: true,\n    delay: 5000,\n    maxAttempts: 5,\n};\nconst NORMAL_CLOSE_CODE = 1000; // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\nclass SocketProvider extends web3_eip1193_provider_js_1.Eip1193Provider {\n    /**\n     * This is an abstract class for implementing a socket provider (e.g. WebSocket, IPC). It extends the EIP-1193 provider {@link EIP1193Provider}.\n     * @param socketPath - The path to the socket (e.g. /ipc/path or ws://localhost:8546)\n     * @param socketOptions - The options for the socket connection. Its type is supposed to be specified in the inherited classes.\n     * @param reconnectOptions - The options for the socket reconnection {@link ReconnectOptions}\n     */\n    constructor(socketPath, socketOptions, reconnectOptions) {\n        super();\n        this._connectionStatus = 'connecting';\n        // Message handlers. Due to bounding of `this` and removing the listeners we have to keep it's reference.\n        this._onMessageHandler = this._onMessage.bind(this);\n        this._onOpenHandler = this._onConnect.bind(this);\n        this._onCloseHandler = this._onCloseEvent.bind(this);\n        this._onErrorHandler = this._onError.bind(this);\n        if (!this._validateProviderPath(socketPath))\n            throw new web3_errors_1.InvalidClientError(socketPath);\n        this._socketPath = socketPath;\n        this._socketOptions = socketOptions;\n        this._reconnectOptions = Object.assign(Object.assign({}, DEFAULT_RECONNECTION_OPTIONS), (reconnectOptions !== null && reconnectOptions !== void 0 ? reconnectOptions : {}));\n        this._pendingRequestsQueue = new Map();\n        this._sentRequestsQueue = new Map();\n        this._init();\n        this.connect();\n        this.chunkResponseParser = new chunk_response_parser_js_1.ChunkResponseParser(this._eventEmitter, this._reconnectOptions.autoReconnect);\n        this.chunkResponseParser.onError(() => {\n            this._clearQueues();\n        });\n        this.isReconnecting = false;\n    }\n    get SocketConnection() {\n        return this._socketConnection;\n    }\n    _init() {\n        this._reconnectAttempts = 0;\n    }\n    /**\n     * Try to establish a connection to the socket\n     */\n    connect() {\n        try {\n            this._openSocketConnection();\n            this._connectionStatus = 'connecting';\n            this._addSocketListeners();\n        }\n        catch (e) {\n            if (!this.isReconnecting) {\n                this._connectionStatus = 'disconnected';\n                if (e && e.message) {\n                    throw new web3_errors_1.ConnectionError(`Error while connecting to ${this._socketPath}. Reason: ${e.message}`);\n                }\n                else {\n                    throw new web3_errors_1.InvalidClientError(this._socketPath);\n                }\n            }\n            else {\n                setImmediate(() => {\n                    this._reconnect();\n                });\n            }\n        }\n    }\n    // eslint-disable-next-line class-methods-use-this\n    _validateProviderPath(path) {\n        return !!path;\n    }\n    /**\n     *\n     * @returns the pendingRequestQueue size\n     */\n    // eslint-disable-next-line class-methods-use-this\n    getPendingRequestQueueSize() {\n        return this._pendingRequestsQueue.size;\n    }\n    /**\n     *\n     * @returns the sendPendingRequests size\n     */\n    // eslint-disable-next-line class-methods-use-this\n    getSentRequestsQueueSize() {\n        return this._sentRequestsQueue.size;\n    }\n    /**\n     *\n     * @returns `true` if the socket supports subscriptions\n     */\n    // eslint-disable-next-line class-methods-use-this\n    supportsSubscriptions() {\n        return true;\n    }\n    on(type, listener) {\n        this._eventEmitter.on(type, listener);\n    }\n    once(type, listener) {\n        this._eventEmitter.once(type, listener);\n    }\n    removeListener(type, listener) {\n        this._eventEmitter.removeListener(type, listener);\n    }\n    _onDisconnect(code, data) {\n        this._connectionStatus = 'disconnected';\n        super._onDisconnect(code, data);\n    }\n    /**\n     * Disconnects the socket\n     * @param code - The code to be sent to the server\n     * @param data - The data to be sent to the server\n     */\n    disconnect(code, data) {\n        const disconnectCode = code !== null && code !== void 0 ? code : NORMAL_CLOSE_CODE;\n        this._removeSocketListeners();\n        if (this.getStatus() !== 'disconnected') {\n            this._closeSocketConnection(disconnectCode, data);\n        }\n        this._onDisconnect(disconnectCode, data);\n    }\n    /**\n     * Safely disconnects the socket, async and waits for request size to be 0 before disconnecting\n     * @param forceDisconnect - If true, will clear queue after 5 attempts of waiting for both pending and sent queue to be 0\n     * @param ms - Determines the ms of setInterval\n     * @param code - The code to be sent to the server\n     * @param data - The data to be sent to the server\n     */\n    safeDisconnect(code, data, forceDisconnect = false, ms = 1000) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let retryAttempt = 0;\n            const checkQueue = () => __awaiter(this, void 0, void 0, function* () {\n                return new Promise(resolve => {\n                    const interval = setInterval(() => {\n                        if (forceDisconnect && retryAttempt === 5) {\n                            this.clearQueues();\n                        }\n                        if (this.getPendingRequestQueueSize() === 0 && this.getSentRequestsQueueSize() === 0) {\n                            clearInterval(interval);\n                            resolve(true);\n                        }\n                        retryAttempt += 1;\n                    }, ms);\n                });\n            });\n            yield checkQueue();\n            this.disconnect(code, data);\n        });\n    }\n    /**\n     * Removes all listeners for the specified event type.\n     * @param type - The event type to remove the listeners for\n     */\n    removeAllListeners(type) {\n        this._eventEmitter.removeAllListeners(type);\n    }\n    _onError(event) {\n        // do not emit error while trying to reconnect\n        if (this.isReconnecting) {\n            this._reconnect();\n        }\n        else {\n            this._eventEmitter.emit('error', event);\n        }\n    }\n    /**\n     * Resets the socket, removing all listeners and pending requests\n     */\n    reset() {\n        this._sentRequestsQueue.clear();\n        this._pendingRequestsQueue.clear();\n        this._init();\n        this._removeSocketListeners();\n        this._addSocketListeners();\n    }\n    _reconnect() {\n        if (this.isReconnecting) {\n            return;\n        }\n        this.isReconnecting = true;\n        if (this._sentRequestsQueue.size > 0) {\n            this._sentRequestsQueue.forEach((request, key) => {\n                request.deferredPromise.reject(new web3_errors_1.PendingRequestsOnReconnectingError());\n                this._sentRequestsQueue.delete(key);\n            });\n        }\n        if (this._reconnectAttempts < this._reconnectOptions.maxAttempts) {\n            this._reconnectAttempts += 1;\n            setTimeout(() => {\n                this._removeSocketListeners();\n                this.connect();\n                this.isReconnecting = false;\n            }, this._reconnectOptions.delay);\n        }\n        else {\n            this.isReconnecting = false;\n            this._clearQueues();\n            this._removeSocketListeners();\n            this._eventEmitter.emit('error', new web3_errors_1.MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts));\n        }\n    }\n    /**\n     *  Creates a request object to be sent to the server\n     */\n    request(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if ((0, validation_js_1.isNullish)(this._socketConnection)) {\n                throw new Error('Connection is undefined');\n            }\n            // if socket disconnected - open connection\n            if (this.getStatus() === 'disconnected') {\n                this.connect();\n            }\n            const requestId = jsonRpc.isBatchRequest(request)\n                ? request[0].id\n                : request.id;\n            if (!requestId) {\n                throw new web3_errors_1.Web3WSProviderError('Request Id not defined');\n            }\n            if (this._sentRequestsQueue.has(requestId)) {\n                throw new web3_errors_1.RequestAlreadySentError(requestId);\n            }\n            const deferredPromise = new web3_deferred_promise_js_1.Web3DeferredPromise();\n            deferredPromise.catch(error => {\n                this._eventEmitter.emit('error', error);\n            });\n            const reqItem = {\n                payload: request,\n                deferredPromise,\n            };\n            if (this.getStatus() === 'connecting') {\n                this._pendingRequestsQueue.set(requestId, reqItem);\n                return reqItem.deferredPromise;\n            }\n            this._sentRequestsQueue.set(requestId, reqItem);\n            try {\n                this._sendToSocket(reqItem.payload);\n            }\n            catch (error) {\n                this._sentRequestsQueue.delete(requestId);\n                this._eventEmitter.emit('error', error);\n            }\n            return deferredPromise;\n        });\n    }\n    _onConnect() {\n        this._connectionStatus = 'connected';\n        this._reconnectAttempts = 0;\n        super._onConnect();\n        this._sendPendingRequests();\n    }\n    _sendPendingRequests() {\n        for (const [id, value] of this._pendingRequestsQueue.entries()) {\n            this._sendToSocket(value.payload);\n            this._pendingRequestsQueue.delete(id);\n            this._sentRequestsQueue.set(id, value);\n        }\n    }\n    _onMessage(event) {\n        const responses = this._parseResponses(event);\n        if ((0, validation_js_1.isNullish)(responses) || responses.length === 0) {\n            return;\n        }\n        for (const response of responses) {\n            if (jsonRpc.isResponseWithNotification(response) &&\n                response.method.endsWith('_subscription')) {\n                this._eventEmitter.emit('message', response);\n                return;\n            }\n            const requestId = jsonRpc.isBatchResponse(response)\n                ? response[0].id\n                : response.id;\n            const requestItem = this._sentRequestsQueue.get(requestId);\n            if (!requestItem) {\n                return;\n            }\n            if (jsonRpc.isBatchResponse(response) ||\n                jsonRpc.isResponseWithResult(response) ||\n                jsonRpc.isResponseWithError(response)) {\n                this._eventEmitter.emit('message', response);\n                requestItem.deferredPromise.resolve(response);\n            }\n            this._sentRequestsQueue.delete(requestId);\n        }\n    }\n    clearQueues(event) {\n        this._clearQueues(event);\n    }\n    _clearQueues(event) {\n        if (this._pendingRequestsQueue.size > 0) {\n            this._pendingRequestsQueue.forEach((request, key) => {\n                request.deferredPromise.reject(new web3_errors_1.ConnectionNotOpenError(event));\n                this._pendingRequestsQueue.delete(key);\n            });\n        }\n        if (this._sentRequestsQueue.size > 0) {\n            this._sentRequestsQueue.forEach((request, key) => {\n                request.deferredPromise.reject(new web3_errors_1.ConnectionNotOpenError(event));\n                this._sentRequestsQueue.delete(key);\n            });\n        }\n        this._removeSocketListeners();\n    }\n}\nexports.SocketProvider = SocketProvider;\n//# sourceMappingURL=socket_provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9zb2NrZXRfcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsc0JBQXNCLG1CQUFPLENBQUMseUZBQWE7QUFDM0MsbUNBQW1DLG1CQUFPLENBQUMsdUhBQTRCO0FBQ3ZFLG1DQUFtQyxtQkFBTyxDQUFDLHVIQUE0QjtBQUN2RSx3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBaUI7QUFDakQsbUNBQW1DLG1CQUFPLENBQUMsdUhBQTRCO0FBQ3ZFLDZCQUE2QixtQkFBTyxDQUFDLDZGQUFlO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLDZIQUE2SCxzQkFBc0I7QUFDbko7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxrSEFBa0g7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLGlCQUFpQixZQUFZLFVBQVU7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2lzc3Vlcl9ob2xkZXJfdmVyaWZpZXIvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9zb2NrZXRfcHJvdmlkZXIuanM/OGU4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvY2tldFByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3Qgd2ViM19lcnJvcnNfMSA9IHJlcXVpcmUoXCJ3ZWIzLWVycm9yc1wiKTtcbmNvbnN0IHdlYjNfZWlwMTE5M19wcm92aWRlcl9qc18xID0gcmVxdWlyZShcIi4vd2ViM19laXAxMTkzX3Byb3ZpZGVyLmpzXCIpO1xuY29uc3QgY2h1bmtfcmVzcG9uc2VfcGFyc2VyX2pzXzEgPSByZXF1aXJlKFwiLi9jaHVua19yZXNwb25zZV9wYXJzZXIuanNcIik7XG5jb25zdCB2YWxpZGF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0aW9uLmpzXCIpO1xuY29uc3Qgd2ViM19kZWZlcnJlZF9wcm9taXNlX2pzXzEgPSByZXF1aXJlKFwiLi93ZWIzX2RlZmVycmVkX3Byb21pc2UuanNcIik7XG5jb25zdCBqc29uUnBjID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2pzb25fcnBjLmpzXCIpKTtcbmNvbnN0IERFRkFVTFRfUkVDT05ORUNUSU9OX09QVElPTlMgPSB7XG4gICAgYXV0b1JlY29ubmVjdDogdHJ1ZSxcbiAgICBkZWxheTogNTAwMCxcbiAgICBtYXhBdHRlbXB0czogNSxcbn07XG5jb25zdCBOT1JNQUxfQ0xPU0VfQ09ERSA9IDEwMDA7IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXQvY2xvc2VcbmNsYXNzIFNvY2tldFByb3ZpZGVyIGV4dGVuZHMgd2ViM19laXAxMTkzX3Byb3ZpZGVyX2pzXzEuRWlwMTE5M1Byb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGFuIGFic3RyYWN0IGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgYSBzb2NrZXQgcHJvdmlkZXIgKGUuZy4gV2ViU29ja2V0LCBJUEMpLiBJdCBleHRlbmRzIHRoZSBFSVAtMTE5MyBwcm92aWRlciB7QGxpbmsgRUlQMTE5M1Byb3ZpZGVyfS5cbiAgICAgKiBAcGFyYW0gc29ja2V0UGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBzb2NrZXQgKGUuZy4gL2lwYy9wYXRoIG9yIHdzOi8vbG9jYWxob3N0Ojg1NDYpXG4gICAgICogQHBhcmFtIHNvY2tldE9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHNvY2tldCBjb25uZWN0aW9uLiBJdHMgdHlwZSBpcyBzdXBwb3NlZCB0byBiZSBzcGVjaWZpZWQgaW4gdGhlIGluaGVyaXRlZCBjbGFzc2VzLlxuICAgICAqIEBwYXJhbSByZWNvbm5lY3RPcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBzb2NrZXQgcmVjb25uZWN0aW9uIHtAbGluayBSZWNvbm5lY3RPcHRpb25zfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNvY2tldFBhdGgsIHNvY2tldE9wdGlvbnMsIHJlY29ubmVjdE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXR1cyA9ICdjb25uZWN0aW5nJztcbiAgICAgICAgLy8gTWVzc2FnZSBoYW5kbGVycy4gRHVlIHRvIGJvdW5kaW5nIG9mIGB0aGlzYCBhbmQgcmVtb3ZpbmcgdGhlIGxpc3RlbmVycyB3ZSBoYXZlIHRvIGtlZXAgaXQncyByZWZlcmVuY2UuXG4gICAgICAgIHRoaXMuX29uTWVzc2FnZUhhbmRsZXIgPSB0aGlzLl9vbk1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fb25PcGVuSGFuZGxlciA9IHRoaXMuX29uQ29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9vbkNsb3NlSGFuZGxlciA9IHRoaXMuX29uQ2xvc2VFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9vbkVycm9ySGFuZGxlciA9IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZVByb3ZpZGVyUGF0aChzb2NrZXRQYXRoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyB3ZWIzX2Vycm9yc18xLkludmFsaWRDbGllbnRFcnJvcihzb2NrZXRQYXRoKTtcbiAgICAgICAgdGhpcy5fc29ja2V0UGF0aCA9IHNvY2tldFBhdGg7XG4gICAgICAgIHRoaXMuX3NvY2tldE9wdGlvbnMgPSBzb2NrZXRPcHRpb25zO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1JFQ09OTkVDVElPTl9PUFRJT05TKSwgKHJlY29ubmVjdE9wdGlvbnMgIT09IG51bGwgJiYgcmVjb25uZWN0T3B0aW9ucyAhPT0gdm9pZCAwID8gcmVjb25uZWN0T3B0aW9ucyA6IHt9KSk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1F1ZXVlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zZW50UmVxdWVzdHNRdWV1ZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5jaHVua1Jlc3BvbnNlUGFyc2VyID0gbmV3IGNodW5rX3Jlc3BvbnNlX3BhcnNlcl9qc18xLkNodW5rUmVzcG9uc2VQYXJzZXIodGhpcy5fZXZlbnRFbWl0dGVyLCB0aGlzLl9yZWNvbm5lY3RPcHRpb25zLmF1dG9SZWNvbm5lY3QpO1xuICAgICAgICB0aGlzLmNodW5rUmVzcG9uc2VQYXJzZXIub25FcnJvcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclF1ZXVlcygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgU29ja2V0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvY2tldENvbm5lY3Rpb247XG4gICAgfVxuICAgIF9pbml0KCkge1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyeSB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHRvIHRoZSBzb2NrZXRcbiAgICAgKi9cbiAgICBjb25uZWN0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fb3BlblNvY2tldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0dXMgPSAnY29ubmVjdGluZyc7XG4gICAgICAgICAgICB0aGlzLl9hZGRTb2NrZXRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXR1cyA9ICdkaXNjb25uZWN0ZWQnO1xuICAgICAgICAgICAgICAgIGlmIChlICYmIGUubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgd2ViM19lcnJvcnNfMS5Db25uZWN0aW9uRXJyb3IoYEVycm9yIHdoaWxlIGNvbm5lY3RpbmcgdG8gJHt0aGlzLl9zb2NrZXRQYXRofS4gUmVhc29uOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyB3ZWIzX2Vycm9yc18xLkludmFsaWRDbGllbnRFcnJvcih0aGlzLl9zb2NrZXRQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIF92YWxpZGF0ZVByb3ZpZGVyUGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiAhIXBhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIHBlbmRpbmdSZXF1ZXN0UXVldWUgc2l6ZVxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgZ2V0UGVuZGluZ1JlcXVlc3RRdWV1ZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nUmVxdWVzdHNRdWV1ZS5zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBzZW5kUGVuZGluZ1JlcXVlc3RzIHNpemVcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIGdldFNlbnRSZXF1ZXN0c1F1ZXVlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbnRSZXF1ZXN0c1F1ZXVlLnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBzb2NrZXQgc3VwcG9ydHMgc3Vic2NyaXB0aW9uc1xuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgc3VwcG9ydHNTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLm9uKHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIub25jZSh0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIF9vbkRpc2Nvbm5lY3QoY29kZSwgZGF0YSkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHVzID0gJ2Rpc2Nvbm5lY3RlZCc7XG4gICAgICAgIHN1cGVyLl9vbkRpc2Nvbm5lY3QoY29kZSwgZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXRcbiAgICAgKiBAcGFyYW0gY29kZSAtIFRoZSBjb2RlIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyXG4gICAgICovXG4gICAgZGlzY29ubmVjdChjb2RlLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGRpc2Nvbm5lY3RDb2RlID0gY29kZSAhPT0gbnVsbCAmJiBjb2RlICE9PSB2b2lkIDAgPyBjb2RlIDogTk9STUFMX0NMT1NFX0NPREU7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNvY2tldExpc3RlbmVycygpO1xuICAgICAgICBpZiAodGhpcy5nZXRTdGF0dXMoKSAhPT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlU29ja2V0Q29ubmVjdGlvbihkaXNjb25uZWN0Q29kZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb25EaXNjb25uZWN0KGRpc2Nvbm5lY3RDb2RlLCBkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2FmZWx5IGRpc2Nvbm5lY3RzIHRoZSBzb2NrZXQsIGFzeW5jIGFuZCB3YWl0cyBmb3IgcmVxdWVzdCBzaXplIHRvIGJlIDAgYmVmb3JlIGRpc2Nvbm5lY3RpbmdcbiAgICAgKiBAcGFyYW0gZm9yY2VEaXNjb25uZWN0IC0gSWYgdHJ1ZSwgd2lsbCBjbGVhciBxdWV1ZSBhZnRlciA1IGF0dGVtcHRzIG9mIHdhaXRpbmcgZm9yIGJvdGggcGVuZGluZyBhbmQgc2VudCBxdWV1ZSB0byBiZSAwXG4gICAgICogQHBhcmFtIG1zIC0gRGV0ZXJtaW5lcyB0aGUgbXMgb2Ygc2V0SW50ZXJ2YWxcbiAgICAgKiBAcGFyYW0gY29kZSAtIFRoZSBjb2RlIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyXG4gICAgICovXG4gICAgc2FmZURpc2Nvbm5lY3QoY29kZSwgZGF0YSwgZm9yY2VEaXNjb25uZWN0ID0gZmFsc2UsIG1zID0gMTAwMCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHJldHJ5QXR0ZW1wdCA9IDA7XG4gICAgICAgICAgICBjb25zdCBjaGVja1F1ZXVlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9yY2VEaXNjb25uZWN0ICYmIHJldHJ5QXR0ZW1wdCA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJRdWV1ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldFBlbmRpbmdSZXF1ZXN0UXVldWVTaXplKCkgPT09IDAgJiYgdGhpcy5nZXRTZW50UmVxdWVzdHNRdWV1ZVNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeUF0dGVtcHQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSwgbXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCBjaGVja1F1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoY29kZSwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSBldmVudCB0eXBlIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJzIGZvclxuICAgICAqL1xuICAgIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnModHlwZSk7XG4gICAgfVxuICAgIF9vbkVycm9yKGV2ZW50KSB7XG4gICAgICAgIC8vIGRvIG5vdCBlbWl0IGVycm9yIHdoaWxlIHRyeWluZyB0byByZWNvbm5lY3RcbiAgICAgICAgaWYgKHRoaXMuaXNSZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgc29ja2V0LCByZW1vdmluZyBhbGwgbGlzdGVuZXJzIGFuZCBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX3NlbnRSZXF1ZXN0c1F1ZXVlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1F1ZXVlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU29ja2V0TGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX2FkZFNvY2tldExpc3RlbmVycygpO1xuICAgIH1cbiAgICBfcmVjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5pc1JlY29ubmVjdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fc2VudFJlcXVlc3RzUXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbnRSZXF1ZXN0c1F1ZXVlLmZvckVhY2goKHJlcXVlc3QsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuZGVmZXJyZWRQcm9taXNlLnJlamVjdChuZXcgd2ViM19lcnJvcnNfMS5QZW5kaW5nUmVxdWVzdHNPblJlY29ubmVjdGluZ0Vycm9yKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbnRSZXF1ZXN0c1F1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JlY29ubmVjdEF0dGVtcHRzIDwgdGhpcy5fcmVjb25uZWN0T3B0aW9ucy5tYXhBdHRlbXB0cykge1xuICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0QXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNvY2tldExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIHRoaXMuX3JlY29ubmVjdE9wdGlvbnMuZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJRdWV1ZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNvY2tldExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmVtaXQoJ2Vycm9yJywgbmV3IHdlYjNfZXJyb3JzXzEuTWF4QXR0ZW1wdHNSZWFjaGVkT25SZWNvbm5lY3RpbmdFcnJvcih0aGlzLl9yZWNvbm5lY3RPcHRpb25zLm1heEF0dGVtcHRzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSByZXF1ZXN0IG9iamVjdCB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICByZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICgoMCwgdmFsaWRhdGlvbl9qc18xLmlzTnVsbGlzaCkodGhpcy5fc29ja2V0Q29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gaXMgdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBzb2NrZXQgZGlzY29ubmVjdGVkIC0gb3BlbiBjb25uZWN0aW9uXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRTdGF0dXMoKSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IGpzb25ScGMuaXNCYXRjaFJlcXVlc3QocmVxdWVzdClcbiAgICAgICAgICAgICAgICA/IHJlcXVlc3RbMF0uaWRcbiAgICAgICAgICAgICAgICA6IHJlcXVlc3QuaWQ7XG4gICAgICAgICAgICBpZiAoIXJlcXVlc3RJZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyB3ZWIzX2Vycm9yc18xLldlYjNXU1Byb3ZpZGVyRXJyb3IoJ1JlcXVlc3QgSWQgbm90IGRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9zZW50UmVxdWVzdHNRdWV1ZS5oYXMocmVxdWVzdElkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyB3ZWIzX2Vycm9yc18xLlJlcXVlc3RBbHJlYWR5U2VudEVycm9yKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZFByb21pc2UgPSBuZXcgd2ViM19kZWZlcnJlZF9wcm9taXNlX2pzXzEuV2ViM0RlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICAgICAgZGVmZXJyZWRQcm9taXNlLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlcUl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZFByb21pc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0U3RhdHVzKCkgPT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1F1ZXVlLnNldChyZXF1ZXN0SWQsIHJlcUl0ZW0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXFJdGVtLmRlZmVycmVkUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NlbnRSZXF1ZXN0c1F1ZXVlLnNldChyZXF1ZXN0SWQsIHJlcUl0ZW0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW5kVG9Tb2NrZXQocmVxSXRlbS5wYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbnRSZXF1ZXN0c1F1ZXVlLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZFByb21pc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfb25Db25uZWN0KCkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHVzID0gJ2Nvbm5lY3RlZCc7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgc3VwZXIuX29uQ29ubmVjdCgpO1xuICAgICAgICB0aGlzLl9zZW5kUGVuZGluZ1JlcXVlc3RzKCk7XG4gICAgfVxuICAgIF9zZW5kUGVuZGluZ1JlcXVlc3RzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtpZCwgdmFsdWVdIG9mIHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1F1ZXVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgdGhpcy5fc2VuZFRvU29ja2V0KHZhbHVlLnBheWxvYWQpO1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RzUXVldWUuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbnRSZXF1ZXN0c1F1ZXVlLnNldChpZCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9vbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gdGhpcy5fcGFyc2VSZXNwb25zZXMoZXZlbnQpO1xuICAgICAgICBpZiAoKDAsIHZhbGlkYXRpb25fanNfMS5pc051bGxpc2gpKHJlc3BvbnNlcykgfHwgcmVzcG9uc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcmVzcG9uc2Ugb2YgcmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBpZiAoanNvblJwYy5pc1Jlc3BvbnNlV2l0aE5vdGlmaWNhdGlvbihyZXNwb25zZSkgJiZcbiAgICAgICAgICAgICAgICByZXNwb25zZS5tZXRob2QuZW5kc1dpdGgoJ19zdWJzY3JpcHRpb24nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5lbWl0KCdtZXNzYWdlJywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IGpzb25ScGMuaXNCYXRjaFJlc3BvbnNlKHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgID8gcmVzcG9uc2VbMF0uaWRcbiAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLmlkO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEl0ZW0gPSB0aGlzLl9zZW50UmVxdWVzdHNRdWV1ZS5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgIGlmICghcmVxdWVzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNvblJwYy5pc0JhdGNoUmVzcG9uc2UocmVzcG9uc2UpIHx8XG4gICAgICAgICAgICAgICAganNvblJwYy5pc1Jlc3BvbnNlV2l0aFJlc3VsdChyZXNwb25zZSkgfHxcbiAgICAgICAgICAgICAgICBqc29uUnBjLmlzUmVzcG9uc2VXaXRoRXJyb3IocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmVtaXQoJ21lc3NhZ2UnLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEl0ZW0uZGVmZXJyZWRQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2VudFJlcXVlc3RzUXVldWUuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJRdWV1ZXMoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJRdWV1ZXMoZXZlbnQpO1xuICAgIH1cbiAgICBfY2xlYXJRdWV1ZXMoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1F1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHNRdWV1ZS5mb3JFYWNoKChyZXF1ZXN0LCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmRlZmVycmVkUHJvbWlzZS5yZWplY3QobmV3IHdlYjNfZXJyb3JzXzEuQ29ubmVjdGlvbk5vdE9wZW5FcnJvcihldmVudCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1F1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3NlbnRSZXF1ZXN0c1F1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zZW50UmVxdWVzdHNRdWV1ZS5mb3JFYWNoKChyZXF1ZXN0LCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmRlZmVycmVkUHJvbWlzZS5yZWplY3QobmV3IHdlYjNfZXJyb3JzXzEuQ29ubmVjdGlvbk5vdE9wZW5FcnJvcihldmVudCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbnRSZXF1ZXN0c1F1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3ZlU29ja2V0TGlzdGVuZXJzKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Tb2NrZXRQcm92aWRlciA9IFNvY2tldFByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ja2V0X3Byb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/socket_provider.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/string_manipulation.js":
/*!***********************************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/string_manipulation.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromTwosComplement = exports.toTwosComplement = exports.leftPad = exports.rightPad = exports.padRight = exports.padLeft = void 0;\nconst web3_errors_1 = __webpack_require__(/*! web3-errors */ \"(api)/./src/pages/api/node_modules/web3-errors/lib/commonjs/index.js\");\nconst web3_validator_1 = __webpack_require__(/*! web3-validator */ \"(api)/./src/pages/api/node_modules/web3-validator/lib/commonjs/index.js\");\nconst converters_js_1 = __webpack_require__(/*! ./converters.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/converters.js\");\n/**\n * Adds a padding on the left of a string, if value is a integer or bigInt will be converted to a hex string.\n * @param value - The value to be padded.\n * @param characterAmount - The amount of characters the string should have.\n * @param sign - The sign to be added (default is 0).\n * @returns The padded string.\n *\n * @example\n * ```ts\n *\n * console.log(web3.utils.padLeft('0x123', 10));\n * >0x0000000123\n * ```\n */\nconst padLeft = (value, characterAmount, sign = '0') => {\n    // To avoid duplicate code and circular dependency we will\n    // use `padLeft` implementation from `web3-validator`\n    if (typeof value === 'string') {\n        if (!(0, web3_validator_1.isHexStrict)(value)) {\n            return value.padStart(characterAmount, sign);\n        }\n        return web3_validator_1.utils.padLeft(value, characterAmount, sign);\n    }\n    web3_validator_1.validator.validate(['int'], [value]);\n    return web3_validator_1.utils.padLeft(value, characterAmount, sign);\n};\nexports.padLeft = padLeft;\n/**\n * Adds a padding on the right of a string, if value is a integer or bigInt will be converted to a hex string.\n * @param value - The value to be padded.\n * @param characterAmount - The amount of characters the string should have.\n * @param sign - The sign to be added (default is 0).\n * @returns The padded string.\n *\n * @example\n * ```ts\n * console.log(web3.utils.padRight('0x123', 10));\n * > 0x1230000000\n *\n * console.log(web3.utils.padRight('0x123', 10, '1'));\n * > 0x1231111111\n * ```\n */\nconst padRight = (value, characterAmount, sign = '0') => {\n    if (typeof value === 'string' && !(0, web3_validator_1.isHexStrict)(value)) {\n        return value.padEnd(characterAmount, sign);\n    }\n    web3_validator_1.validator.validate(['int'], [value]);\n    const hexString = typeof value === 'string' && (0, web3_validator_1.isHexStrict)(value) ? value : (0, converters_js_1.numberToHex)(value);\n    const prefixLength = hexString.startsWith('-') ? 3 : 2;\n    return hexString.padEnd(characterAmount + prefixLength, sign);\n};\nexports.padRight = padRight;\n/**\n * Adds a padding on the right of a string, if value is a integer or bigInt will be converted to a hex string. @alias `padRight`\n */\nexports.rightPad = exports.padRight;\n/**\n * Adds a padding on the left of a string, if value is a integer or bigInt will be converted to a hex string. @alias `padLeft`\n */\nexports.leftPad = exports.padLeft;\n/**\n * Converts a negative number into the two’s complement and return a hexstring of 64 nibbles.\n * @param value - The value to be converted.\n * @param nibbleWidth - The nibble width of the hex string (default is 64).\n *\n * @returns The hex string of the two’s complement.\n *\n * @example\n * ```ts\n * console.log(web3.utils.toTwosComplement(13, 32));\n * > 0x0000000000000000000000000000000d\n *\n * console.log(web3.utils.toTwosComplement('-0x1', 32));\n * > 0xffffffffffffffffffffffffffffffff\n *\n * console.log(web3.utils.toTwosComplement(BigInt('9007199254740992'), 32));\n * > 0x00000000000000000020000000000000\n * ```\n */\nconst toTwosComplement = (value, nibbleWidth = 64) => {\n    web3_validator_1.validator.validate(['int'], [value]);\n    const val = (0, converters_js_1.toNumber)(value);\n    if (val >= 0)\n        return (0, exports.padLeft)((0, converters_js_1.toHex)(val), nibbleWidth);\n    const largestBit = (0, web3_validator_1.bigintPower)(BigInt(2), BigInt(nibbleWidth * 4));\n    if (-val >= largestBit) {\n        throw new web3_errors_1.NibbleWidthError(`value: ${value}, nibbleWidth: ${nibbleWidth}`);\n    }\n    const updatedVal = BigInt(val);\n    const complement = updatedVal + largestBit;\n    return (0, exports.padLeft)((0, converters_js_1.numberToHex)(complement), nibbleWidth);\n};\nexports.toTwosComplement = toTwosComplement;\n/**\n * Converts the twos complement into a decimal number or big int.\n * @param value - The value to be converted.\n * @param nibbleWidth - The nibble width of the hex string (default is 64).\n * @returns The decimal number or big int.\n *\n * @example\n * ```ts\n * console.log(web3.utils.fromTwosComplement('0x0000000000000000000000000000000d', 32'));\n * > 13\n *\n * console.log(web3.utils.fromTwosComplement('0x00000000000000000020000000000000', 32));\n * > 9007199254740992n\n * ```\n */\nconst fromTwosComplement = (value, nibbleWidth = 64) => {\n    web3_validator_1.validator.validate(['int'], [value]);\n    const val = (0, converters_js_1.toNumber)(value);\n    if (val < 0)\n        return val;\n    const largestBit = Math.ceil(Math.log(Number(val)) / Math.log(2));\n    if (largestBit > nibbleWidth * 4)\n        throw new web3_errors_1.NibbleWidthError(`value: \"${value}\", nibbleWidth: \"${nibbleWidth}\"`);\n    // check the largest bit to see if negative\n    if (nibbleWidth * 4 !== largestBit)\n        return val;\n    const complement = (0, web3_validator_1.bigintPower)(BigInt(2), BigInt(nibbleWidth) * BigInt(4));\n    return (0, converters_js_1.toNumber)(BigInt(val) - complement);\n};\nexports.fromTwosComplement = fromTwosComplement;\n//# sourceMappingURL=string_manipulation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9zdHJpbmdfbWFuaXB1bGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyx3QkFBd0IsR0FBRyxlQUFlLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZUFBZTtBQUMvSCxzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUMzQyx5QkFBeUIsbUJBQU8sQ0FBQywrRkFBZ0I7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsaUdBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELE1BQU0saUJBQWlCLFlBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNLG1CQUFtQixZQUFZO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2lzc3Vlcl9ob2xkZXJfdmVyaWZpZXIvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy9zdHJpbmdfbWFuaXB1bGF0aW9uLmpzP2I5MzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxud2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG5pdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbnRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4oYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG53ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG5idXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbllvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZnJvbVR3b3NDb21wbGVtZW50ID0gZXhwb3J0cy50b1R3b3NDb21wbGVtZW50ID0gZXhwb3J0cy5sZWZ0UGFkID0gZXhwb3J0cy5yaWdodFBhZCA9IGV4cG9ydHMucGFkUmlnaHQgPSBleHBvcnRzLnBhZExlZnQgPSB2b2lkIDA7XG5jb25zdCB3ZWIzX2Vycm9yc18xID0gcmVxdWlyZShcIndlYjMtZXJyb3JzXCIpO1xuY29uc3Qgd2ViM192YWxpZGF0b3JfMSA9IHJlcXVpcmUoXCJ3ZWIzLXZhbGlkYXRvclwiKTtcbmNvbnN0IGNvbnZlcnRlcnNfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMuanNcIik7XG4vKipcbiAqIEFkZHMgYSBwYWRkaW5nIG9uIHRoZSBsZWZ0IG9mIGEgc3RyaW5nLCBpZiB2YWx1ZSBpcyBhIGludGVnZXIgb3IgYmlnSW50IHdpbGwgYmUgY29udmVydGVkIHRvIGEgaGV4IHN0cmluZy5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBwYWRkZWQuXG4gKiBAcGFyYW0gY2hhcmFjdGVyQW1vdW50IC0gVGhlIGFtb3VudCBvZiBjaGFyYWN0ZXJzIHRoZSBzdHJpbmcgc2hvdWxkIGhhdmUuXG4gKiBAcGFyYW0gc2lnbiAtIFRoZSBzaWduIHRvIGJlIGFkZGVkIChkZWZhdWx0IGlzIDApLlxuICogQHJldHVybnMgVGhlIHBhZGRlZCBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKlxuICogY29uc29sZS5sb2cod2ViMy51dGlscy5wYWRMZWZ0KCcweDEyMycsIDEwKSk7XG4gKiA+MHgwMDAwMDAwMTIzXG4gKiBgYGBcbiAqL1xuY29uc3QgcGFkTGVmdCA9ICh2YWx1ZSwgY2hhcmFjdGVyQW1vdW50LCBzaWduID0gJzAnKSA9PiB7XG4gICAgLy8gVG8gYXZvaWQgZHVwbGljYXRlIGNvZGUgYW5kIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2Ugd2lsbFxuICAgIC8vIHVzZSBgcGFkTGVmdGAgaW1wbGVtZW50YXRpb24gZnJvbSBgd2ViMy12YWxpZGF0b3JgXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCEoMCwgd2ViM192YWxpZGF0b3JfMS5pc0hleFN0cmljdCkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucGFkU3RhcnQoY2hhcmFjdGVyQW1vdW50LCBzaWduKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2ViM192YWxpZGF0b3JfMS51dGlscy5wYWRMZWZ0KHZhbHVlLCBjaGFyYWN0ZXJBbW91bnQsIHNpZ24pO1xuICAgIH1cbiAgICB3ZWIzX3ZhbGlkYXRvcl8xLnZhbGlkYXRvci52YWxpZGF0ZShbJ2ludCddLCBbdmFsdWVdKTtcbiAgICByZXR1cm4gd2ViM192YWxpZGF0b3JfMS51dGlscy5wYWRMZWZ0KHZhbHVlLCBjaGFyYWN0ZXJBbW91bnQsIHNpZ24pO1xufTtcbmV4cG9ydHMucGFkTGVmdCA9IHBhZExlZnQ7XG4vKipcbiAqIEFkZHMgYSBwYWRkaW5nIG9uIHRoZSByaWdodCBvZiBhIHN0cmluZywgaWYgdmFsdWUgaXMgYSBpbnRlZ2VyIG9yIGJpZ0ludCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGhleCBzdHJpbmcuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgcGFkZGVkLlxuICogQHBhcmFtIGNoYXJhY3RlckFtb3VudCAtIFRoZSBhbW91bnQgb2YgY2hhcmFjdGVycyB0aGUgc3RyaW5nIHNob3VsZCBoYXZlLlxuICogQHBhcmFtIHNpZ24gLSBUaGUgc2lnbiB0byBiZSBhZGRlZCAoZGVmYXVsdCBpcyAwKS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkZWQgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc29sZS5sb2cod2ViMy51dGlscy5wYWRSaWdodCgnMHgxMjMnLCAxMCkpO1xuICogPiAweDEyMzAwMDAwMDBcbiAqXG4gKiBjb25zb2xlLmxvZyh3ZWIzLnV0aWxzLnBhZFJpZ2h0KCcweDEyMycsIDEwLCAnMScpKTtcbiAqID4gMHgxMjMxMTExMTExXG4gKiBgYGBcbiAqL1xuY29uc3QgcGFkUmlnaHQgPSAodmFsdWUsIGNoYXJhY3RlckFtb3VudCwgc2lnbiA9ICcwJykgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICEoMCwgd2ViM192YWxpZGF0b3JfMS5pc0hleFN0cmljdCkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5wYWRFbmQoY2hhcmFjdGVyQW1vdW50LCBzaWduKTtcbiAgICB9XG4gICAgd2ViM192YWxpZGF0b3JfMS52YWxpZGF0b3IudmFsaWRhdGUoWydpbnQnXSwgW3ZhbHVlXSk7XG4gICAgY29uc3QgaGV4U3RyaW5nID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAoMCwgd2ViM192YWxpZGF0b3JfMS5pc0hleFN0cmljdCkodmFsdWUpID8gdmFsdWUgOiAoMCwgY29udmVydGVyc19qc18xLm51bWJlclRvSGV4KSh2YWx1ZSk7XG4gICAgY29uc3QgcHJlZml4TGVuZ3RoID0gaGV4U3RyaW5nLnN0YXJ0c1dpdGgoJy0nKSA/IDMgOiAyO1xuICAgIHJldHVybiBoZXhTdHJpbmcucGFkRW5kKGNoYXJhY3RlckFtb3VudCArIHByZWZpeExlbmd0aCwgc2lnbik7XG59O1xuZXhwb3J0cy5wYWRSaWdodCA9IHBhZFJpZ2h0O1xuLyoqXG4gKiBBZGRzIGEgcGFkZGluZyBvbiB0aGUgcmlnaHQgb2YgYSBzdHJpbmcsIGlmIHZhbHVlIGlzIGEgaW50ZWdlciBvciBiaWdJbnQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBoZXggc3RyaW5nLiBAYWxpYXMgYHBhZFJpZ2h0YFxuICovXG5leHBvcnRzLnJpZ2h0UGFkID0gZXhwb3J0cy5wYWRSaWdodDtcbi8qKlxuICogQWRkcyBhIHBhZGRpbmcgb24gdGhlIGxlZnQgb2YgYSBzdHJpbmcsIGlmIHZhbHVlIGlzIGEgaW50ZWdlciBvciBiaWdJbnQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBoZXggc3RyaW5nLiBAYWxpYXMgYHBhZExlZnRgXG4gKi9cbmV4cG9ydHMubGVmdFBhZCA9IGV4cG9ydHMucGFkTGVmdDtcbi8qKlxuICogQ29udmVydHMgYSBuZWdhdGl2ZSBudW1iZXIgaW50byB0aGUgdHdv4oCZcyBjb21wbGVtZW50IGFuZCByZXR1cm4gYSBoZXhzdHJpbmcgb2YgNjQgbmliYmxlcy5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBjb252ZXJ0ZWQuXG4gKiBAcGFyYW0gbmliYmxlV2lkdGggLSBUaGUgbmliYmxlIHdpZHRoIG9mIHRoZSBoZXggc3RyaW5nIChkZWZhdWx0IGlzIDY0KS5cbiAqXG4gKiBAcmV0dXJucyBUaGUgaGV4IHN0cmluZyBvZiB0aGUgdHdv4oCZcyBjb21wbGVtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc29sZS5sb2cod2ViMy51dGlscy50b1R3b3NDb21wbGVtZW50KDEzLCAzMikpO1xuICogPiAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBkXG4gKlxuICogY29uc29sZS5sb2cod2ViMy51dGlscy50b1R3b3NDb21wbGVtZW50KCctMHgxJywgMzIpKTtcbiAqID4gMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlxuICpcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMudG9Ud29zQ29tcGxlbWVudChCaWdJbnQoJzkwMDcxOTkyNTQ3NDA5OTInKSwgMzIpKTtcbiAqID4gMHgwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMFxuICogYGBgXG4gKi9cbmNvbnN0IHRvVHdvc0NvbXBsZW1lbnQgPSAodmFsdWUsIG5pYmJsZVdpZHRoID0gNjQpID0+IHtcbiAgICB3ZWIzX3ZhbGlkYXRvcl8xLnZhbGlkYXRvci52YWxpZGF0ZShbJ2ludCddLCBbdmFsdWVdKTtcbiAgICBjb25zdCB2YWwgPSAoMCwgY29udmVydGVyc19qc18xLnRvTnVtYmVyKSh2YWx1ZSk7XG4gICAgaWYgKHZhbCA+PSAwKVxuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMucGFkTGVmdCkoKDAsIGNvbnZlcnRlcnNfanNfMS50b0hleCkodmFsKSwgbmliYmxlV2lkdGgpO1xuICAgIGNvbnN0IGxhcmdlc3RCaXQgPSAoMCwgd2ViM192YWxpZGF0b3JfMS5iaWdpbnRQb3dlcikoQmlnSW50KDIpLCBCaWdJbnQobmliYmxlV2lkdGggKiA0KSk7XG4gICAgaWYgKC12YWwgPj0gbGFyZ2VzdEJpdCkge1xuICAgICAgICB0aHJvdyBuZXcgd2ViM19lcnJvcnNfMS5OaWJibGVXaWR0aEVycm9yKGB2YWx1ZTogJHt2YWx1ZX0sIG5pYmJsZVdpZHRoOiAke25pYmJsZVdpZHRofWApO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVkVmFsID0gQmlnSW50KHZhbCk7XG4gICAgY29uc3QgY29tcGxlbWVudCA9IHVwZGF0ZWRWYWwgKyBsYXJnZXN0Qml0O1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5wYWRMZWZ0KSgoMCwgY29udmVydGVyc19qc18xLm51bWJlclRvSGV4KShjb21wbGVtZW50KSwgbmliYmxlV2lkdGgpO1xufTtcbmV4cG9ydHMudG9Ud29zQ29tcGxlbWVudCA9IHRvVHdvc0NvbXBsZW1lbnQ7XG4vKipcbiAqIENvbnZlcnRzIHRoZSB0d29zIGNvbXBsZW1lbnQgaW50byBhIGRlY2ltYWwgbnVtYmVyIG9yIGJpZyBpbnQuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgY29udmVydGVkLlxuICogQHBhcmFtIG5pYmJsZVdpZHRoIC0gVGhlIG5pYmJsZSB3aWR0aCBvZiB0aGUgaGV4IHN0cmluZyAoZGVmYXVsdCBpcyA2NCkuXG4gKiBAcmV0dXJucyBUaGUgZGVjaW1hbCBudW1iZXIgb3IgYmlnIGludC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnNvbGUubG9nKHdlYjMudXRpbHMuZnJvbVR3b3NDb21wbGVtZW50KCcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBkJywgMzInKSk7XG4gKiA+IDEzXG4gKlxuICogY29uc29sZS5sb2cod2ViMy51dGlscy5mcm9tVHdvc0NvbXBsZW1lbnQoJzB4MDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAnLCAzMikpO1xuICogPiA5MDA3MTk5MjU0NzQwOTkyblxuICogYGBgXG4gKi9cbmNvbnN0IGZyb21Ud29zQ29tcGxlbWVudCA9ICh2YWx1ZSwgbmliYmxlV2lkdGggPSA2NCkgPT4ge1xuICAgIHdlYjNfdmFsaWRhdG9yXzEudmFsaWRhdG9yLnZhbGlkYXRlKFsnaW50J10sIFt2YWx1ZV0pO1xuICAgIGNvbnN0IHZhbCA9ICgwLCBjb252ZXJ0ZXJzX2pzXzEudG9OdW1iZXIpKHZhbHVlKTtcbiAgICBpZiAodmFsIDwgMClcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICBjb25zdCBsYXJnZXN0Qml0ID0gTWF0aC5jZWlsKE1hdGgubG9nKE51bWJlcih2YWwpKSAvIE1hdGgubG9nKDIpKTtcbiAgICBpZiAobGFyZ2VzdEJpdCA+IG5pYmJsZVdpZHRoICogNClcbiAgICAgICAgdGhyb3cgbmV3IHdlYjNfZXJyb3JzXzEuTmliYmxlV2lkdGhFcnJvcihgdmFsdWU6IFwiJHt2YWx1ZX1cIiwgbmliYmxlV2lkdGg6IFwiJHtuaWJibGVXaWR0aH1cImApO1xuICAgIC8vIGNoZWNrIHRoZSBsYXJnZXN0IGJpdCB0byBzZWUgaWYgbmVnYXRpdmVcbiAgICBpZiAobmliYmxlV2lkdGggKiA0ICE9PSBsYXJnZXN0Qml0KVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIGNvbnN0IGNvbXBsZW1lbnQgPSAoMCwgd2ViM192YWxpZGF0b3JfMS5iaWdpbnRQb3dlcikoQmlnSW50KDIpLCBCaWdJbnQobmliYmxlV2lkdGgpICogQmlnSW50KDQpKTtcbiAgICByZXR1cm4gKDAsIGNvbnZlcnRlcnNfanNfMS50b051bWJlcikoQmlnSW50KHZhbCkgLSBjb21wbGVtZW50KTtcbn07XG5leHBvcnRzLmZyb21Ud29zQ29tcGxlbWVudCA9IGZyb21Ud29zQ29tcGxlbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ19tYW5pcHVsYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/string_manipulation.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/uint8array.js":
/*!**************************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/uint8array.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uint8ArrayEquals = exports.uint8ArrayConcat = exports.isUint8Array = void 0;\nfunction isUint8Array(data) {\n    var _a;\n    return (data instanceof Uint8Array ||\n        ((_a = data === null || data === void 0 ? void 0 : data.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'Uint8Array');\n}\nexports.isUint8Array = isUint8Array;\nfunction uint8ArrayConcat(...parts) {\n    const length = parts.reduce((prev, part) => {\n        const agg = prev + part.length;\n        return agg;\n    }, 0);\n    const result = new Uint8Array(length);\n    let offset = 0;\n    for (const part of parts) {\n        result.set(part, offset);\n        offset += part.length;\n    }\n    return result;\n}\nexports.uint8ArrayConcat = uint8ArrayConcat;\n/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nfunction uint8ArrayEquals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.byteLength !== b.byteLength) {\n        return false;\n    }\n    for (let i = 0; i < a.byteLength; i += 1) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.uint8ArrayEquals = uint8ArrayEquals;\n//# sourceMappingURL=uint8array.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy91aW50OGFycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3N1ZXJfaG9sZGVyX3ZlcmlmaWVyLy4vc3JjL3BhZ2VzL2FwaS9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvY29tbW9uanMvdWludDhhcnJheS5qcz9jOTNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcblRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbndlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG50aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxud2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbk1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbkdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG5Zb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbmFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVpbnQ4QXJyYXlFcXVhbHMgPSBleHBvcnRzLnVpbnQ4QXJyYXlDb25jYXQgPSBleHBvcnRzLmlzVWludDhBcnJheSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGlzVWludDhBcnJheShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKChfYSA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09PSAnVWludDhBcnJheScpO1xufVxuZXhwb3J0cy5pc1VpbnQ4QXJyYXkgPSBpc1VpbnQ4QXJyYXk7XG5mdW5jdGlvbiB1aW50OEFycmF5Q29uY2F0KC4uLnBhcnRzKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gcGFydHMucmVkdWNlKChwcmV2LCBwYXJ0KSA9PiB7XG4gICAgICAgIGNvbnN0IGFnZyA9IHByZXYgKyBwYXJ0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGFnZztcbiAgICB9LCAwKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICByZXN1bHQuc2V0KHBhcnQsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBwYXJ0Lmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudWludDhBcnJheUNvbmNhdCA9IHVpbnQ4QXJyYXlDb25jYXQ7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIHBhc3NlZCBVaW50OEFycmF5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnRcbiAqL1xuZnVuY3Rpb24gdWludDhBcnJheUVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5ieXRlTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMudWludDhBcnJheUVxdWFscyA9IHVpbnQ4QXJyYXlFcXVhbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11aW50OGFycmF5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/uint8array.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/uuid.js":
/*!********************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/uuid.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uuidV4 = void 0;\n/**\n * @module Utils\n */\nconst converters_js_1 = __webpack_require__(/*! ./converters.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/converters.js\");\nconst random_js_1 = __webpack_require__(/*! ./random.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/random.js\");\n/**\n * Generate a version 4 (random) uuid\n * https://github.com/uuidjs/uuid/blob/main/src/v4.js#L5\n * @returns - A version 4 uuid of the form xxxxxxxx-xxxx-4xxx-xxxx-xxxxxxxxxxxx\n * @example\n * ```ts\n * console.log(web3.utils.uuidV4());\n * > \"1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed\"\n * ```\n */\nconst uuidV4 = () => {\n    const bytes = (0, random_js_1.randomBytes)(16);\n    // https://github.com/ethers-io/ethers.js/blob/ce8f1e4015c0f27bf178238770b1325136e3351a/packages/json-wallets/src.ts/utils.ts#L54\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    /* eslint-disable-next-line */\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    /* eslint-disable-next-line */\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n    const hexString = (0, converters_js_1.bytesToHex)(bytes);\n    return [\n        hexString.substring(2, 10),\n        hexString.substring(10, 14),\n        hexString.substring(14, 18),\n        hexString.substring(18, 22),\n        hexString.substring(22, 34),\n    ].join('-');\n};\nexports.uuidV4 = uuidV4;\n//# sourceMappingURL=uuid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy91dWlkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsaUdBQWlCO0FBQ2pELG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXNzdWVyX2hvbGRlcl92ZXJpZmllci8uL3NyYy9wYWdlcy9hcGkvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL2NvbW1vbmpzL3V1aWQuanM/Mjg1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG5UaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG53ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbml0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxudGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbihhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbndlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbmJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG5NRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG5HTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG5hbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51dWlkVjQgPSB2b2lkIDA7XG4vKipcbiAqIEBtb2R1bGUgVXRpbHNcbiAqL1xuY29uc3QgY29udmVydGVyc19qc18xID0gcmVxdWlyZShcIi4vY29udmVydGVycy5qc1wiKTtcbmNvbnN0IHJhbmRvbV9qc18xID0gcmVxdWlyZShcIi4vcmFuZG9tLmpzXCIpO1xuLyoqXG4gKiBHZW5lcmF0ZSBhIHZlcnNpb24gNCAocmFuZG9tKSB1dWlkXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvYmxvYi9tYWluL3NyYy92NC5qcyNMNVxuICogQHJldHVybnMgLSBBIHZlcnNpb24gNCB1dWlkIG9mIHRoZSBmb3JtIHh4eHh4eHh4LXh4eHgtNHh4eC14eHh4LXh4eHh4eHh4eHh4eFxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zb2xlLmxvZyh3ZWIzLnV0aWxzLnV1aWRWNCgpKTtcbiAqID4gXCIxYjlkNmJjZC1iYmZkLTRiMmQtOWI1ZC1hYjhkZmJiZDRiZWRcIlxuICogYGBgXG4gKi9cbmNvbnN0IHV1aWRWNCA9ICgpID0+IHtcbiAgICBjb25zdCBieXRlcyA9ICgwLCByYW5kb21fanNfMS5yYW5kb21CeXRlcykoMTYpO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcnMtaW8vZXRoZXJzLmpzL2Jsb2IvY2U4ZjFlNDAxNWMwZjI3YmYxNzgyMzg3NzBiMTMyNTEzNmUzMzUxYS9wYWNrYWdlcy9qc29uLXdhbGxldHMvc3JjLnRzL3V0aWxzLnRzI0w1NFxuICAgIC8vIFNlY3Rpb246IDQuMS4zOlxuICAgIC8vIC0gdGltZV9oaV9hbmRfdmVyc2lvblsxMjoxNl0gPSAwYjAxMDBcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgKi9cbiAgICBieXRlc1s2XSA9IChieXRlc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgICAvLyBTZWN0aW9uIDQuNFxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs2XSA9IDBiMFxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs3XSA9IDBiMVxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAqL1xuICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHgzZikgfCAweDgwO1xuICAgIGNvbnN0IGhleFN0cmluZyA9ICgwLCBjb252ZXJ0ZXJzX2pzXzEuYnl0ZXNUb0hleCkoYnl0ZXMpO1xuICAgIHJldHVybiBbXG4gICAgICAgIGhleFN0cmluZy5zdWJzdHJpbmcoMiwgMTApLFxuICAgICAgICBoZXhTdHJpbmcuc3Vic3RyaW5nKDEwLCAxNCksXG4gICAgICAgIGhleFN0cmluZy5zdWJzdHJpbmcoMTQsIDE4KSxcbiAgICAgICAgaGV4U3RyaW5nLnN1YnN0cmluZygxOCwgMjIpLFxuICAgICAgICBoZXhTdHJpbmcuc3Vic3RyaW5nKDIyLCAzNCksXG4gICAgXS5qb2luKCctJyk7XG59O1xuZXhwb3J0cy51dWlkVjQgPSB1dWlkVjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dWlkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/uuid.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/validation.js":
/*!**************************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/validation.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isNullish = exports.isContractInitOptions = exports.compareBlockNumbers = exports.isTopicInBloom = exports.isTopic = exports.isContractAddressInBloom = exports.isUserEthereumAddressInBloom = exports.isInBloom = exports.isBloom = exports.isAddress = exports.checkAddressCheckSum = exports.isHex = exports.isHexStrict = void 0;\n/**\n * @module Utils\n */\nconst web3_errors_1 = __webpack_require__(/*! web3-errors */ \"(api)/./src/pages/api/node_modules/web3-errors/lib/commonjs/index.js\");\nconst web3_validator_1 = __webpack_require__(/*! web3-validator */ \"(api)/./src/pages/api/node_modules/web3-validator/lib/commonjs/index.js\");\nconst web3_types_1 = __webpack_require__(/*! web3-types */ \"(api)/./src/pages/api/node_modules/web3-types/lib/commonjs/index.js\");\n/**\n * @deprecated Will be removed in next release. Please use `web3-validator` package instead.\n */\nexports.isHexStrict = web3_validator_1.isHexStrict;\n/**\n * returns true if input is a hexstring, number or bigint\n *\n * @deprecated Will be removed in next release. Please use `web3-validator` package instead.\n */\nexports.isHex = web3_validator_1.isHex;\n/**\n * Checks the checksum of a given address. Will also return false on non-checksum addresses.\n *\n * @deprecated Will be removed in next release. Please use `web3-validator` package instead.\n */\nexports.checkAddressCheckSum = web3_validator_1.checkAddressCheckSum;\n/**\n * Checks if a given string is a valid Ethereum address. It will also check the checksum, if the address has upper and lowercase letters.\n *\n * @deprecated Will be removed in next release. Please use `web3-validator` package instead.\n */\nexports.isAddress = web3_validator_1.isAddress;\n/**\n * Returns true if the bloom is a valid bloom\n * https://github.com/joshstevens19/ethereum-bloom-filters/blob/fbeb47b70b46243c3963fe1c2988d7461ef17236/src/index.ts#L7\n *\n * @deprecated Will be removed in next release. Please use `web3-validator` package instead.\n */\nexports.isBloom = web3_validator_1.isBloom;\n/**\n * Returns true if the value is part of the given bloom\n * note: false positives are possible.\n *\n * @deprecated Will be removed in next release. Please use `web3-validator` package instead.\n */\nexports.isInBloom = web3_validator_1.isInBloom;\n/**\n * Returns true if the ethereum users address is part of the given bloom note: false positives are possible.\n *\n * @deprecated Will be removed in next release. Please use `web3-validator` package instead.\n */\nexports.isUserEthereumAddressInBloom = web3_validator_1.isUserEthereumAddressInBloom;\n/**\n * Returns true if the contract address is part of the given bloom.\n * note: false positives are possible.\n *\n * @deprecated Will be removed in next release. Please use `web3-validator` package instead.\n */\nexports.isContractAddressInBloom = web3_validator_1.isContractAddressInBloom;\n/**\n * Checks if its a valid topic\n *\n * @deprecated Will be removed in next release. Please use `web3-validator` package instead.\n */\nexports.isTopic = web3_validator_1.isTopic;\n/**\n * Returns true if the topic is part of the given bloom.\n * note: false positives are possible.\n *\n * @deprecated Will be removed in next release. Please use `web3-validator` package instead.\n */\nexports.isTopicInBloom = web3_validator_1.isTopicInBloom;\n/**\n * Compares between block A and block B\n * @param blockA - Block number or string\n * @param blockB - Block number or string\n *\n * @returns - Returns -1 if a \\< b, returns 1 if a \\> b and returns 0 if a == b\n *\n * @example\n * ```ts\n * console.log(web3.utils.compareBlockNumbers('latest', 'pending'));\n * > -1\n *\n * console.log(web3.utils.compareBlockNumbers(12, 11));\n * > 1\n * ```\n */\nconst compareBlockNumbers = (blockA, blockB) => {\n    const isABlockTag = typeof blockA === 'string' && (0, web3_validator_1.isBlockTag)(blockA);\n    const isBBlockTag = typeof blockB === 'string' && (0, web3_validator_1.isBlockTag)(blockB);\n    if (blockA === blockB ||\n        ((blockA === 'earliest' || blockA === 0) && (blockB === 'earliest' || blockB === 0)) // only exception compare blocktag with number\n    ) {\n        return 0;\n    }\n    if (blockA === 'earliest' && blockB > 0) {\n        return -1;\n    }\n    if (blockB === 'earliest' && blockA > 0) {\n        return 1;\n    }\n    if (isABlockTag && isBBlockTag) {\n        // Increasing order:  earliest, finalized , safe, latest, pending\n        const tagsOrder = {\n            [web3_types_1.BlockTags.EARLIEST]: 1,\n            [web3_types_1.BlockTags.FINALIZED]: 2,\n            [web3_types_1.BlockTags.SAFE]: 3,\n            [web3_types_1.BlockTags.LATEST]: 4,\n            [web3_types_1.BlockTags.PENDING]: 5,\n        };\n        if (tagsOrder[blockA] < tagsOrder[blockB]) {\n            return -1;\n        }\n        return 1;\n    }\n    if ((isABlockTag && !isBBlockTag) || (!isABlockTag && isBBlockTag)) {\n        throw new web3_errors_1.InvalidBlockError('Cannot compare blocktag with provided non-blocktag input.');\n    }\n    const bigIntA = BigInt(blockA);\n    const bigIntB = BigInt(blockB);\n    if (bigIntA < bigIntB) {\n        return -1;\n    }\n    if (bigIntA === bigIntB) {\n        return 0;\n    }\n    return 1;\n};\nexports.compareBlockNumbers = compareBlockNumbers;\nconst isContractInitOptions = (options) => typeof options === 'object' &&\n    !(0, web3_validator_1.isNullish)(options) &&\n    Object.keys(options).length !== 0 &&\n    [\n        'input',\n        'data',\n        'from',\n        'gas',\n        'gasPrice',\n        'gasLimit',\n        'address',\n        'jsonInterface',\n        'syncWithContext',\n        'dataInputFill',\n    ].some(key => key in options);\nexports.isContractInitOptions = isContractInitOptions;\nexports.isNullish = web3_validator_1.isNullish;\n//# sourceMappingURL=validation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy92YWxpZGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyw2QkFBNkIsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxlQUFlLEdBQUcsZ0NBQWdDLEdBQUcsb0NBQW9DLEdBQUcsaUJBQWlCLEdBQUcsZUFBZSxHQUFHLGlCQUFpQixHQUFHLDRCQUE0QixHQUFHLGFBQWEsR0FBRyxtQkFBbUI7QUFDblU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMseUZBQWE7QUFDM0MseUJBQXlCLG1CQUFPLENBQUMsK0ZBQWdCO0FBQ2pELHFCQUFxQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXNzdWVyX2hvbGRlcl92ZXJpZmllci8uL3NyYy9wYWdlcy9hcGkvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL2NvbW1vbmpzL3ZhbGlkYXRpb24uanM/N2VjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG5UaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG53ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbml0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxudGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbihhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbndlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbmJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG5NRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG5HTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG5hbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc051bGxpc2ggPSBleHBvcnRzLmlzQ29udHJhY3RJbml0T3B0aW9ucyA9IGV4cG9ydHMuY29tcGFyZUJsb2NrTnVtYmVycyA9IGV4cG9ydHMuaXNUb3BpY0luQmxvb20gPSBleHBvcnRzLmlzVG9waWMgPSBleHBvcnRzLmlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbSA9IGV4cG9ydHMuaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbSA9IGV4cG9ydHMuaXNJbkJsb29tID0gZXhwb3J0cy5pc0Jsb29tID0gZXhwb3J0cy5pc0FkZHJlc3MgPSBleHBvcnRzLmNoZWNrQWRkcmVzc0NoZWNrU3VtID0gZXhwb3J0cy5pc0hleCA9IGV4cG9ydHMuaXNIZXhTdHJpY3QgPSB2b2lkIDA7XG4vKipcbiAqIEBtb2R1bGUgVXRpbHNcbiAqL1xuY29uc3Qgd2ViM19lcnJvcnNfMSA9IHJlcXVpcmUoXCJ3ZWIzLWVycm9yc1wiKTtcbmNvbnN0IHdlYjNfdmFsaWRhdG9yXzEgPSByZXF1aXJlKFwid2ViMy12YWxpZGF0b3JcIik7XG5jb25zdCB3ZWIzX3R5cGVzXzEgPSByZXF1aXJlKFwid2ViMy10eXBlc1wiKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIG5leHQgcmVsZWFzZS4gUGxlYXNlIHVzZSBgd2ViMy12YWxpZGF0b3JgIHBhY2thZ2UgaW5zdGVhZC5cbiAqL1xuZXhwb3J0cy5pc0hleFN0cmljdCA9IHdlYjNfdmFsaWRhdG9yXzEuaXNIZXhTdHJpY3Q7XG4vKipcbiAqIHJldHVybnMgdHJ1ZSBpZiBpbnB1dCBpcyBhIGhleHN0cmluZywgbnVtYmVyIG9yIGJpZ2ludFxuICpcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiBuZXh0IHJlbGVhc2UuIFBsZWFzZSB1c2UgYHdlYjMtdmFsaWRhdG9yYCBwYWNrYWdlIGluc3RlYWQuXG4gKi9cbmV4cG9ydHMuaXNIZXggPSB3ZWIzX3ZhbGlkYXRvcl8xLmlzSGV4O1xuLyoqXG4gKiBDaGVja3MgdGhlIGNoZWNrc3VtIG9mIGEgZ2l2ZW4gYWRkcmVzcy4gV2lsbCBhbHNvIHJldHVybiBmYWxzZSBvbiBub24tY2hlY2tzdW0gYWRkcmVzc2VzLlxuICpcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiBuZXh0IHJlbGVhc2UuIFBsZWFzZSB1c2UgYHdlYjMtdmFsaWRhdG9yYCBwYWNrYWdlIGluc3RlYWQuXG4gKi9cbmV4cG9ydHMuY2hlY2tBZGRyZXNzQ2hlY2tTdW0gPSB3ZWIzX3ZhbGlkYXRvcl8xLmNoZWNrQWRkcmVzc0NoZWNrU3VtO1xuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBzdHJpbmcgaXMgYSB2YWxpZCBFdGhlcmV1bSBhZGRyZXNzLiBJdCB3aWxsIGFsc28gY2hlY2sgdGhlIGNoZWNrc3VtLCBpZiB0aGUgYWRkcmVzcyBoYXMgdXBwZXIgYW5kIGxvd2VyY2FzZSBsZXR0ZXJzLlxuICpcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiBuZXh0IHJlbGVhc2UuIFBsZWFzZSB1c2UgYHdlYjMtdmFsaWRhdG9yYCBwYWNrYWdlIGluc3RlYWQuXG4gKi9cbmV4cG9ydHMuaXNBZGRyZXNzID0gd2ViM192YWxpZGF0b3JfMS5pc0FkZHJlc3M7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYmxvb20gaXMgYSB2YWxpZCBibG9vbVxuICogaHR0cHM6Ly9naXRodWIuY29tL2pvc2hzdGV2ZW5zMTkvZXRoZXJldW0tYmxvb20tZmlsdGVycy9ibG9iL2ZiZWI0N2I3MGI0NjI0M2MzOTYzZmUxYzI5ODhkNzQ2MWVmMTcyMzYvc3JjL2luZGV4LnRzI0w3XG4gKlxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIG5leHQgcmVsZWFzZS4gUGxlYXNlIHVzZSBgd2ViMy12YWxpZGF0b3JgIHBhY2thZ2UgaW5zdGVhZC5cbiAqL1xuZXhwb3J0cy5pc0Jsb29tID0gd2ViM192YWxpZGF0b3JfMS5pc0Jsb29tO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIHBhcnQgb2YgdGhlIGdpdmVuIGJsb29tXG4gKiBub3RlOiBmYWxzZSBwb3NpdGl2ZXMgYXJlIHBvc3NpYmxlLlxuICpcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiBuZXh0IHJlbGVhc2UuIFBsZWFzZSB1c2UgYHdlYjMtdmFsaWRhdG9yYCBwYWNrYWdlIGluc3RlYWQuXG4gKi9cbmV4cG9ydHMuaXNJbkJsb29tID0gd2ViM192YWxpZGF0b3JfMS5pc0luQmxvb207XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXRoZXJldW0gdXNlcnMgYWRkcmVzcyBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbSBub3RlOiBmYWxzZSBwb3NpdGl2ZXMgYXJlIHBvc3NpYmxlLlxuICpcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiBuZXh0IHJlbGVhc2UuIFBsZWFzZSB1c2UgYHdlYjMtdmFsaWRhdG9yYCBwYWNrYWdlIGluc3RlYWQuXG4gKi9cbmV4cG9ydHMuaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbSA9IHdlYjNfdmFsaWRhdG9yXzEuaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250cmFjdCBhZGRyZXNzIGlzIHBhcnQgb2YgdGhlIGdpdmVuIGJsb29tLlxuICogbm90ZTogZmFsc2UgcG9zaXRpdmVzIGFyZSBwb3NzaWJsZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gbmV4dCByZWxlYXNlLiBQbGVhc2UgdXNlIGB3ZWIzLXZhbGlkYXRvcmAgcGFja2FnZSBpbnN0ZWFkLlxuICovXG5leHBvcnRzLmlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbSA9IHdlYjNfdmFsaWRhdG9yXzEuaXNDb250cmFjdEFkZHJlc3NJbkJsb29tO1xuLyoqXG4gKiBDaGVja3MgaWYgaXRzIGEgdmFsaWQgdG9waWNcbiAqXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gbmV4dCByZWxlYXNlLiBQbGVhc2UgdXNlIGB3ZWIzLXZhbGlkYXRvcmAgcGFja2FnZSBpbnN0ZWFkLlxuICovXG5leHBvcnRzLmlzVG9waWMgPSB3ZWIzX3ZhbGlkYXRvcl8xLmlzVG9waWM7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdG9waWMgaXMgcGFydCBvZiB0aGUgZ2l2ZW4gYmxvb20uXG4gKiBub3RlOiBmYWxzZSBwb3NpdGl2ZXMgYXJlIHBvc3NpYmxlLlxuICpcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiBuZXh0IHJlbGVhc2UuIFBsZWFzZSB1c2UgYHdlYjMtdmFsaWRhdG9yYCBwYWNrYWdlIGluc3RlYWQuXG4gKi9cbmV4cG9ydHMuaXNUb3BpY0luQmxvb20gPSB3ZWIzX3ZhbGlkYXRvcl8xLmlzVG9waWNJbkJsb29tO1xuLyoqXG4gKiBDb21wYXJlcyBiZXR3ZWVuIGJsb2NrIEEgYW5kIGJsb2NrIEJcbiAqIEBwYXJhbSBibG9ja0EgLSBCbG9jayBudW1iZXIgb3Igc3RyaW5nXG4gKiBAcGFyYW0gYmxvY2tCIC0gQmxvY2sgbnVtYmVyIG9yIHN0cmluZ1xuICpcbiAqIEByZXR1cm5zIC0gUmV0dXJucyAtMSBpZiBhIFxcPCBiLCByZXR1cm5zIDEgaWYgYSBcXD4gYiBhbmQgcmV0dXJucyAwIGlmIGEgPT0gYlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc29sZS5sb2cod2ViMy51dGlscy5jb21wYXJlQmxvY2tOdW1iZXJzKCdsYXRlc3QnLCAncGVuZGluZycpKTtcbiAqID4gLTFcbiAqXG4gKiBjb25zb2xlLmxvZyh3ZWIzLnV0aWxzLmNvbXBhcmVCbG9ja051bWJlcnMoMTIsIDExKSk7XG4gKiA+IDFcbiAqIGBgYFxuICovXG5jb25zdCBjb21wYXJlQmxvY2tOdW1iZXJzID0gKGJsb2NrQSwgYmxvY2tCKSA9PiB7XG4gICAgY29uc3QgaXNBQmxvY2tUYWcgPSB0eXBlb2YgYmxvY2tBID09PSAnc3RyaW5nJyAmJiAoMCwgd2ViM192YWxpZGF0b3JfMS5pc0Jsb2NrVGFnKShibG9ja0EpO1xuICAgIGNvbnN0IGlzQkJsb2NrVGFnID0gdHlwZW9mIGJsb2NrQiA9PT0gJ3N0cmluZycgJiYgKDAsIHdlYjNfdmFsaWRhdG9yXzEuaXNCbG9ja1RhZykoYmxvY2tCKTtcbiAgICBpZiAoYmxvY2tBID09PSBibG9ja0IgfHxcbiAgICAgICAgKChibG9ja0EgPT09ICdlYXJsaWVzdCcgfHwgYmxvY2tBID09PSAwKSAmJiAoYmxvY2tCID09PSAnZWFybGllc3QnIHx8IGJsb2NrQiA9PT0gMCkpIC8vIG9ubHkgZXhjZXB0aW9uIGNvbXBhcmUgYmxvY2t0YWcgd2l0aCBudW1iZXJcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChibG9ja0EgPT09ICdlYXJsaWVzdCcgJiYgYmxvY2tCID4gMCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChibG9ja0IgPT09ICdlYXJsaWVzdCcgJiYgYmxvY2tBID4gMCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGlzQUJsb2NrVGFnICYmIGlzQkJsb2NrVGFnKSB7XG4gICAgICAgIC8vIEluY3JlYXNpbmcgb3JkZXI6ICBlYXJsaWVzdCwgZmluYWxpemVkICwgc2FmZSwgbGF0ZXN0LCBwZW5kaW5nXG4gICAgICAgIGNvbnN0IHRhZ3NPcmRlciA9IHtcbiAgICAgICAgICAgIFt3ZWIzX3R5cGVzXzEuQmxvY2tUYWdzLkVBUkxJRVNUXTogMSxcbiAgICAgICAgICAgIFt3ZWIzX3R5cGVzXzEuQmxvY2tUYWdzLkZJTkFMSVpFRF06IDIsXG4gICAgICAgICAgICBbd2ViM190eXBlc18xLkJsb2NrVGFncy5TQUZFXTogMyxcbiAgICAgICAgICAgIFt3ZWIzX3R5cGVzXzEuQmxvY2tUYWdzLkxBVEVTVF06IDQsXG4gICAgICAgICAgICBbd2ViM190eXBlc18xLkJsb2NrVGFncy5QRU5ESU5HXTogNSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRhZ3NPcmRlcltibG9ja0FdIDwgdGFnc09yZGVyW2Jsb2NrQl0pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKChpc0FCbG9ja1RhZyAmJiAhaXNCQmxvY2tUYWcpIHx8ICghaXNBQmxvY2tUYWcgJiYgaXNCQmxvY2tUYWcpKSB7XG4gICAgICAgIHRocm93IG5ldyB3ZWIzX2Vycm9yc18xLkludmFsaWRCbG9ja0Vycm9yKCdDYW5ub3QgY29tcGFyZSBibG9ja3RhZyB3aXRoIHByb3ZpZGVkIG5vbi1ibG9ja3RhZyBpbnB1dC4nKTtcbiAgICB9XG4gICAgY29uc3QgYmlnSW50QSA9IEJpZ0ludChibG9ja0EpO1xuICAgIGNvbnN0IGJpZ0ludEIgPSBCaWdJbnQoYmxvY2tCKTtcbiAgICBpZiAoYmlnSW50QSA8IGJpZ0ludEIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYmlnSW50QSA9PT0gYmlnSW50Qikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG59O1xuZXhwb3J0cy5jb21wYXJlQmxvY2tOdW1iZXJzID0gY29tcGFyZUJsb2NrTnVtYmVycztcbmNvbnN0IGlzQ29udHJhY3RJbml0T3B0aW9ucyA9IChvcHRpb25zKSA9PiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiZcbiAgICAhKDAsIHdlYjNfdmFsaWRhdG9yXzEuaXNOdWxsaXNoKShvcHRpb25zKSAmJlxuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCAhPT0gMCAmJlxuICAgIFtcbiAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgJ2RhdGEnLFxuICAgICAgICAnZnJvbScsXG4gICAgICAgICdnYXMnLFxuICAgICAgICAnZ2FzUHJpY2UnLFxuICAgICAgICAnZ2FzTGltaXQnLFxuICAgICAgICAnYWRkcmVzcycsXG4gICAgICAgICdqc29uSW50ZXJmYWNlJyxcbiAgICAgICAgJ3N5bmNXaXRoQ29udGV4dCcsXG4gICAgICAgICdkYXRhSW5wdXRGaWxsJyxcbiAgICBdLnNvbWUoa2V5ID0+IGtleSBpbiBvcHRpb25zKTtcbmV4cG9ydHMuaXNDb250cmFjdEluaXRPcHRpb25zID0gaXNDb250cmFjdEluaXRPcHRpb25zO1xuZXhwb3J0cy5pc051bGxpc2ggPSB3ZWIzX3ZhbGlkYXRvcl8xLmlzTnVsbGlzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/validation.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/web3_deferred_promise.js":
/*!*************************************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/web3_deferred_promise.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Web3DeferredPromise = void 0;\nconst web3_errors_1 = __webpack_require__(/*! web3-errors */ \"(api)/./src/pages/api/node_modules/web3-errors/lib/commonjs/index.js\");\n/**\n * The class is a simple implementation of a deferred promise with optional timeout functionality,\n * which can be useful when dealing with asynchronous tasks.\n *\n */\nclass Web3DeferredPromise {\n    /**\n     *\n     * @param timeout - (optional) The timeout in milliseconds.\n     * @param eagerStart - (optional) If true, the timer starts as soon as the promise is created.\n     * @param timeoutMessage - (optional) The message to include in the timeout erro that is thrown when the promise times out.\n     */\n    constructor({ timeout, eagerStart, timeoutMessage, } = {\n        timeout: 0,\n        eagerStart: false,\n        timeoutMessage: 'DeferredPromise timed out',\n    }) {\n        // public tag to treat object as promise by different libs\n        // eslint-disable-next-line @typescript-eslint/prefer-as-const\n        this[_a] = 'Promise';\n        this._state = 'pending';\n        this._promise = new Promise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._timeoutMessage = timeoutMessage;\n        this._timeoutInterval = timeout;\n        if (eagerStart) {\n            this.startTimer();\n        }\n    }\n    /**\n     * Returns the current state of the promise.\n     * @returns 'pending' | 'fulfilled' | 'rejected'\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     *\n     * @param onfulfilled - (optional) The callback to execute when the promise is fulfilled.\n     * @param onrejected  - (optional) The callback to execute when the promise is rejected.\n     * @returns\n     */\n    then(onfulfilled, onrejected) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._promise.then(onfulfilled, onrejected);\n        });\n    }\n    /**\n     *\n     * @param onrejected - (optional) The callback to execute when the promise is rejected.\n     * @returns\n     */\n    catch(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onrejected) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._promise.catch(onrejected);\n        });\n    }\n    /**\n     *\n     * @param onfinally - (optional) The callback to execute when the promise is settled (fulfilled or rejected).\n     * @returns\n     */\n    finally(onfinally) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._promise.finally(onfinally);\n        });\n    }\n    /**\n     * Resolves the current promise.\n     * @param value - The value to resolve the promise with.\n     */\n    resolve(value) {\n        this._resolve(value);\n        this._state = 'fulfilled';\n        this._clearTimeout();\n    }\n    /**\n     * Rejects the current promise.\n     * @param reason - The reason to reject the promise with.\n     */\n    reject(reason) {\n        this._reject(reason);\n        this._state = 'rejected';\n        this._clearTimeout();\n    }\n    /**\n     * Starts the timeout timer for the promise.\n     */\n    startTimer() {\n        if (this._timeoutInterval && this._timeoutInterval > 0) {\n            this._timeoutId = setTimeout(this._checkTimeout.bind(this), this._timeoutInterval);\n        }\n    }\n    _checkTimeout() {\n        if (this._state === 'pending' && this._timeoutId) {\n            this.reject(new web3_errors_1.OperationTimeoutError(this._timeoutMessage));\n        }\n    }\n    _clearTimeout() {\n        if (this._timeoutId) {\n            clearTimeout(this._timeoutId);\n        }\n    }\n}\nexports.Web3DeferredPromise = Web3DeferredPromise;\n_a = Symbol.toStringTag;\n//# sourceMappingURL=web3_deferred_promise.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy93ZWIzX2RlZmVycmVkX3Byb21pc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQixzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUNBQXVDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3N1ZXJfaG9sZGVyX3ZlcmlmaWVyLy4vc3JjL3BhZ2VzL2FwaS9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvY29tbW9uanMvd2ViM19kZWZlcnJlZF9wcm9taXNlLmpzPzZjNWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxud2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG5pdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbnRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4oYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG53ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG5idXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbllvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWIzRGVmZXJyZWRQcm9taXNlID0gdm9pZCAwO1xuY29uc3Qgd2ViM19lcnJvcnNfMSA9IHJlcXVpcmUoXCJ3ZWIzLWVycm9yc1wiKTtcbi8qKlxuICogVGhlIGNsYXNzIGlzIGEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIGEgZGVmZXJyZWQgcHJvbWlzZSB3aXRoIG9wdGlvbmFsIHRpbWVvdXQgZnVuY3Rpb25hbGl0eSxcbiAqIHdoaWNoIGNhbiBiZSB1c2VmdWwgd2hlbiBkZWFsaW5nIHdpdGggYXN5bmNocm9ub3VzIHRhc2tzLlxuICpcbiAqL1xuY2xhc3MgV2ViM0RlZmVycmVkUHJvbWlzZSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZW91dCAtIChvcHRpb25hbCkgVGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEBwYXJhbSBlYWdlclN0YXJ0IC0gKG9wdGlvbmFsKSBJZiB0cnVlLCB0aGUgdGltZXIgc3RhcnRzIGFzIHNvb24gYXMgdGhlIHByb21pc2UgaXMgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0gdGltZW91dE1lc3NhZ2UgLSAob3B0aW9uYWwpIFRoZSBtZXNzYWdlIHRvIGluY2x1ZGUgaW4gdGhlIHRpbWVvdXQgZXJybyB0aGF0IGlzIHRocm93biB3aGVuIHRoZSBwcm9taXNlIHRpbWVzIG91dC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IHRpbWVvdXQsIGVhZ2VyU3RhcnQsIHRpbWVvdXRNZXNzYWdlLCB9ID0ge1xuICAgICAgICB0aW1lb3V0OiAwLFxuICAgICAgICBlYWdlclN0YXJ0OiBmYWxzZSxcbiAgICAgICAgdGltZW91dE1lc3NhZ2U6ICdEZWZlcnJlZFByb21pc2UgdGltZWQgb3V0JyxcbiAgICB9KSB7XG4gICAgICAgIC8vIHB1YmxpYyB0YWcgdG8gdHJlYXQgb2JqZWN0IGFzIHByb21pc2UgYnkgZGlmZmVyZW50IGxpYnNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItYXMtY29uc3RcbiAgICAgICAgdGhpc1tfYV0gPSAnUHJvbWlzZSc7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gJ3BlbmRpbmcnO1xuICAgICAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90aW1lb3V0TWVzc2FnZSA9IHRpbWVvdXRNZXNzYWdlO1xuICAgICAgICB0aGlzLl90aW1lb3V0SW50ZXJ2YWwgPSB0aW1lb3V0O1xuICAgICAgICBpZiAoZWFnZXJTdGFydCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcHJvbWlzZS5cbiAgICAgKiBAcmV0dXJucyAncGVuZGluZycgfCAnZnVsZmlsbGVkJyB8ICdyZWplY3RlZCdcbiAgICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb25mdWxmaWxsZWQgLSAob3B0aW9uYWwpIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLlxuICAgICAqIEBwYXJhbSBvbnJlamVjdGVkICAtIChvcHRpb25hbCkgVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb25yZWplY3RlZCAtIChvcHRpb25hbCkgVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNhdGNoKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgb25yZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2UuY2F0Y2gob25yZWplY3RlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvbmZpbmFsbHkgLSAob3B0aW9uYWwpIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHByb21pc2UgaXMgc2V0dGxlZCAoZnVsZmlsbGVkIG9yIHJlamVjdGVkKS5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGZpbmFsbHkob25maW5hbGx5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZS5maW5hbGx5KG9uZmluYWxseSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgY3VycmVudCBwcm9taXNlLlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGguXG4gICAgICovXG4gICAgcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlamVjdHMgdGhlIGN1cnJlbnQgcHJvbWlzZS5cbiAgICAgKiBAcGFyYW0gcmVhc29uIC0gVGhlIHJlYXNvbiB0byByZWplY3QgdGhlIHByb21pc2Ugd2l0aC5cbiAgICAgKi9cbiAgICByZWplY3QocmVhc29uKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9ICdyZWplY3RlZCc7XG4gICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIHRpbWVvdXQgdGltZXIgZm9yIHRoZSBwcm9taXNlLlxuICAgICAqL1xuICAgIHN0YXJ0VGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl90aW1lb3V0SW50ZXJ2YWwgJiYgdGhpcy5fdGltZW91dEludGVydmFsID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl9jaGVja1RpbWVvdXQuYmluZCh0aGlzKSwgdGhpcy5fdGltZW91dEludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY2hlY2tUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09ICdwZW5kaW5nJyAmJiB0aGlzLl90aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0KG5ldyB3ZWIzX2Vycm9yc18xLk9wZXJhdGlvblRpbWVvdXRFcnJvcih0aGlzLl90aW1lb3V0TWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5XZWIzRGVmZXJyZWRQcm9taXNlID0gV2ViM0RlZmVycmVkUHJvbWlzZTtcbl9hID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViM19kZWZlcnJlZF9wcm9taXNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/web3_deferred_promise.js\n");

/***/ }),

/***/ "(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/web3_eip1193_provider.js":
/*!*************************************************************************************!*\
  !*** ./src/pages/api/node_modules/web3-utils/lib/commonjs/web3_eip1193_provider.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Eip1193Provider = void 0;\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nconst web3_types_1 = __webpack_require__(/*! web3-types */ \"(api)/./src/pages/api/node_modules/web3-types/lib/commonjs/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst web3_errors_1 = __webpack_require__(/*! web3-errors */ \"(api)/./src/pages/api/node_modules/web3-errors/lib/commonjs/index.js\");\nconst json_rpc_js_1 = __webpack_require__(/*! ./json_rpc.js */ \"(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/json_rpc.js\");\n/**\n * This is an abstract class, which extends {@link Web3BaseProvider} class. This class is used to implement a provider that adheres to the EIP-1193 standard for Ethereum providers.\n */\nclass Eip1193Provider extends web3_types_1.Web3BaseProvider {\n    constructor() {\n        super(...arguments);\n        this._eventEmitter = new events_1.EventEmitter();\n        this._chainId = '';\n        this._accounts = [];\n    }\n    _getChainId() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = yield this.request((0, json_rpc_js_1.toPayload)({\n                method: 'eth_chainId',\n                params: [],\n            }));\n            return (_a = data === null || data === void 0 ? void 0 : data.result) !== null && _a !== void 0 ? _a : '';\n        });\n    }\n    _getAccounts() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = yield this.request((0, json_rpc_js_1.toPayload)({\n                method: 'eth_accounts',\n                params: [],\n            }));\n            return (_a = data === null || data === void 0 ? void 0 : data.result) !== null && _a !== void 0 ? _a : [];\n        });\n    }\n    _onConnect() {\n        Promise.all([\n            this._getChainId()\n                .then(chainId => {\n                if (chainId !== this._chainId) {\n                    this._chainId = chainId;\n                    this._eventEmitter.emit('chainChanged', this._chainId);\n                }\n            })\n                .catch(err => {\n                // todo: add error handler\n                console.error(err);\n            }),\n            this._getAccounts()\n                .then(accounts => {\n                if (!(this._accounts.length === accounts.length &&\n                    accounts.every(v => accounts.includes(v)))) {\n                    this._accounts = accounts;\n                    this._onAccountsChanged();\n                }\n            })\n                .catch(err => {\n                // todo: add error handler\n                // eslint-disable-next-line no-console\n                console.error(err);\n            }),\n        ])\n            .then(() => this._eventEmitter.emit('connect', {\n            chainId: this._chainId,\n        }))\n            .catch(err => {\n            // todo: add error handler\n            // eslint-disable-next-line no-console\n            console.error(err);\n        });\n    }\n    // todo this must be ProvideRpcError with a message too\n    _onDisconnect(code, data) {\n        this._eventEmitter.emit('disconnect', new web3_errors_1.EIP1193ProviderRpcError(code, data));\n    }\n    _onAccountsChanged() {\n        // get chainId and safe to local\n        this._eventEmitter.emit('accountsChanged', this._accounts);\n    }\n}\nexports.Eip1193Provider = Eip1193Provider;\n//# sourceMappingURL=web3_eip1193_provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9jb21tb25qcy93ZWIzX2VpcDExOTNfcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsdUZBQVk7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsc0JBQXNCLG1CQUFPLENBQUMseUZBQWE7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsNkZBQWU7QUFDN0M7QUFDQSw2Q0FBNkMsd0JBQXdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3N1ZXJfaG9sZGVyX3ZlcmlmaWVyLy4vc3JjL3BhZ2VzL2FwaS9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvY29tbW9uanMvd2ViM19laXAxMTkzX3Byb3ZpZGVyLmpzPzU1NjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRWlwMTE5M1Byb3ZpZGVyID0gdm9pZCAwO1xuLypcblRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbndlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG50aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxud2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbk1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbkdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG5Zb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbmFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5jb25zdCB3ZWIzX3R5cGVzXzEgPSByZXF1aXJlKFwid2ViMy10eXBlc1wiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHdlYjNfZXJyb3JzXzEgPSByZXF1aXJlKFwid2ViMy1lcnJvcnNcIik7XG5jb25zdCBqc29uX3JwY19qc18xID0gcmVxdWlyZShcIi4vanNvbl9ycGMuanNcIik7XG4vKipcbiAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgY2xhc3MsIHdoaWNoIGV4dGVuZHMge0BsaW5rIFdlYjNCYXNlUHJvdmlkZXJ9IGNsYXNzLiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gaW1wbGVtZW50IGEgcHJvdmlkZXIgdGhhdCBhZGhlcmVzIHRvIHRoZSBFSVAtMTE5MyBzdGFuZGFyZCBmb3IgRXRoZXJldW0gcHJvdmlkZXJzLlxuICovXG5jbGFzcyBFaXAxMTkzUHJvdmlkZXIgZXh0ZW5kcyB3ZWIzX3R5cGVzXzEuV2ViM0Jhc2VQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlciA9IG5ldyBldmVudHNfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fY2hhaW5JZCA9ICcnO1xuICAgICAgICB0aGlzLl9hY2NvdW50cyA9IFtdO1xuICAgIH1cbiAgICBfZ2V0Q2hhaW5JZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHRoaXMucmVxdWVzdCgoMCwganNvbl9ycGNfanNfMS50b1BheWxvYWQpKHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfY2hhaW5JZCcsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEucmVzdWx0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRBY2NvdW50cygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHRoaXMucmVxdWVzdCgoMCwganNvbl9ycGNfanNfMS50b1BheWxvYWQpKHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnJlc3VsdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfb25Db25uZWN0KCkge1xuICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLl9nZXRDaGFpbklkKClcbiAgICAgICAgICAgICAgICAudGhlbihjaGFpbklkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhaW5JZCAhPT0gdGhpcy5fY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYWluQ2hhbmdlZCcsIHRoaXMuX2NoYWluSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbzogYWRkIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRoaXMuX2dldEFjY291bnRzKClcbiAgICAgICAgICAgICAgICAudGhlbihhY2NvdW50cyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcy5fYWNjb3VudHMubGVuZ3RoID09PSBhY2NvdW50cy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudHMuZXZlcnkodiA9PiBhY2NvdW50cy5pbmNsdWRlcyh2KSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjY291bnRzID0gYWNjb3VudHM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQWNjb3VudHNDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvOiBhZGQgZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIF0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLl9ldmVudEVtaXR0ZXIuZW1pdCgnY29ubmVjdCcsIHtcbiAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuX2NoYWluSWQsXG4gICAgICAgIH0pKVxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAvLyB0b2RvOiBhZGQgZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHRvZG8gdGhpcyBtdXN0IGJlIFByb3ZpZGVScGNFcnJvciB3aXRoIGEgbWVzc2FnZSB0b29cbiAgICBfb25EaXNjb25uZWN0KGNvZGUsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmVtaXQoJ2Rpc2Nvbm5lY3QnLCBuZXcgd2ViM19lcnJvcnNfMS5FSVAxMTkzUHJvdmlkZXJScGNFcnJvcihjb2RlLCBkYXRhKSk7XG4gICAgfVxuICAgIF9vbkFjY291bnRzQ2hhbmdlZCgpIHtcbiAgICAgICAgLy8gZ2V0IGNoYWluSWQgYW5kIHNhZmUgdG8gbG9jYWxcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmVtaXQoJ2FjY291bnRzQ2hhbmdlZCcsIHRoaXMuX2FjY291bnRzKTtcbiAgICB9XG59XG5leHBvcnRzLkVpcDExOTNQcm92aWRlciA9IEVpcDExOTNQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYjNfZWlwMTE5M19wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/node_modules/web3-utils/lib/commonjs/web3_eip1193_provider.js\n");

/***/ })

};
;